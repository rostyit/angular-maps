{"version":3,"sources":["ng://angular-maps/src/models/info-window.ts","ng://angular-maps/src/models/marker-type-id.ts","ng://angular-maps/src/models/marker.ts","ng://angular-maps/src/models/map-type-id.ts","ng://angular-maps/src/models/layer.ts","ng://angular-maps/src/models/polygon.ts","ng://angular-maps/src/models/polyline.ts","null","ng://angular-maps/src/models/spider-cluster-marker.ts","ng://angular-maps/src/models/cluster-placement-mode.ts","ng://angular-maps/src/models/cluster-click-action.ts","ng://angular-maps/src/models/canvas-overlay.ts","ng://angular-maps/src/models/bing/bing-layer.ts","ng://angular-maps/src/services/bing/bing-conversions.ts","ng://angular-maps/src/models/bing/bing-marker.ts","ng://angular-maps/src/models/bing/bing-spider-cluster-marker.ts","ng://angular-maps/src/models/bing/bing-cluster-layer.ts","ng://angular-maps/src/models/bing/bing-info-window.ts","ng://angular-maps/src/models/map-label.ts","ng://angular-maps/src/models/extender.ts","ng://angular-maps/src/models/bing/bing-label.ts","ng://angular-maps/src/models/bing/bing-polygon.ts","ng://angular-maps/src/models/bing/bing-polyline.ts","ng://angular-maps/src/models/bing/bing-events-lookup.ts","ng://angular-maps/src/models/bing/bing-canvas-overlay.ts","ng://angular-maps/src/services/google/google-map-types.ts","ng://angular-maps/src/services/google/google-conversions.ts","ng://angular-maps/src/models/google/google-info-window.ts","ng://angular-maps/src/models/google/google-marker.ts","ng://angular-maps/src/models/google/google-label.ts","ng://angular-maps/src/models/google/google-polygon.ts","ng://angular-maps/src/models/google/google-polyline.ts","ng://angular-maps/src/models/google/google-events-lookup.ts","ng://angular-maps/src/models/google/google-canvas-overlay.ts","ng://angular-maps/src/services/mapservicefactory.ts","ng://angular-maps/src/services/map.service.ts","ng://angular-maps/src/services/marker.service.ts","ng://angular-maps/src/services/infobox.service.ts","ng://angular-maps/src/services/layer.service.ts","ng://angular-maps/src/services/polygon.service.ts","ng://angular-maps/src/services/polyline.service.ts","ng://angular-maps/src/services/cluster.service.ts","ng://angular-maps/src/components/infobox-action.ts","ng://angular-maps/src/components/infobox.ts","ng://angular-maps/src/components/map-marker.ts","ng://angular-maps/src/components/map.ts","ng://angular-maps/src/components/map-layer.ts","ng://angular-maps/src/components/cluster-layer.ts","ng://angular-maps/src/components/map-polygon.ts","ng://angular-maps/src/components/map-polyline.ts","ng://angular-maps/src/components/map-marker-layer.ts","ng://angular-maps/src/components/map-polygon-layer.ts","ng://angular-maps/src/components/map-polyline-layer.ts","ng://angular-maps/src/services/mapapiloader.ts","ng://angular-maps/src/services/bing/bing-map.api-loader.service.ts","ng://angular-maps/src/services/bing/bing-infobox.service.ts","ng://angular-maps/src/services/bing/bing-marker.service.ts","ng://angular-maps/src/services/bing/bing-map.service.ts","ng://angular-maps/src/services/bing/bing-layer-base.ts","ng://angular-maps/src/services/bing/bing-layer.service.ts","ng://angular-maps/src/services/bing/bing-cluster.service.ts","ng://angular-maps/src/services/bing/bing-polygon.service.ts","ng://angular-maps/src/services/bing/bing-polyline.service.ts","ng://angular-maps/src/services/bing/bing-map.service.factory.ts","ng://angular-maps/src/services/google/google-layer-base.ts","ng://angular-maps/src/services/google/google-cluster.service.ts","ng://angular-maps/src/services/google/google-infobox.service.ts","ng://angular-maps/src/models/google/google-layer.ts","ng://angular-maps/src/services/google/google-layer.service.ts","ng://angular-maps/src/services/google/google-map-api-loader.service.ts","ng://angular-maps/src/services/google/google-marker.service.ts","ng://angular-maps/src/models/google/google-marker-clusterer.ts","ng://angular-maps/src/services/google/google-map.service.ts","ng://angular-maps/src/services/google/google-polygon.service.ts","ng://angular-maps/src/services/google/google-polyline.service.ts","ng://angular-maps/src/services/google/google-map.service.factory.ts","ng://angular-maps/index.ts"],"names":["InfoWindow","None","FontMarker","CanvasMarker","DynamicCircleMarker","RotatedImageMarker","RoundedImageMarker","ScaledImageMarker","Custom","Marker","CreateMarker","iconInfo","markerType","MarkerTypeId","CreateCanvasMarker","CreateDynamicCircleMarker","CreateFontBasedMarker","CreateRotatedImageMarker","CreateRoundedImageMarker","CreateScaledImageMarker","Error","GetImageForMarker","icon","img","ImageElementCache","get","document","createElement","src","set","size","points","id","MarkerCache","has","mi","markerSize","markerIconString","c","ctx","getContext","width","height","rotation","translate","rotate","Math","PI","fillStyle","color","beginPath","drawingOffset","moveTo","x","y","forEach","p","lineTo","closePath","fill","stroke","s","toDataURL","strokeWidth","toString","join","fontName","fontSize","font","measureText","text","textBaseline","fillText","url","image","Image","Promise","resolve","reject","crossOrigin","onload","rads","ceil","abs","cos","sin","drawImage","radius","offset","arc","clip","scale","Map","aerial","canvasDark","canvasLight","grayscale","hybrid","mercator","ordnanceSurvey","road","streetside","Layer","Polygon","prototype","this","_center","GetBoundingCenter","_centroid","GetPolygonCentroid","latitude","longitude","x1","x2","y1","y2","path","GetPaths","inner","off","twicearea","p1","p2","f","k","length","i","j","Polyline","GetPolylineCentroid","GetPath","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","hasOwnProperty","__extends","__","constructor","create","__read","o","n","m","Symbol","iterator","r","e","call","ar","next","done","push","value","error","__spread","arguments","concat","SpiderClusterMarker","_super","tslib_1.__extends","MeanValue","FirstPin","ZoomIntoCluster","Spider","CanvasOverlay","drawCallback","_this","_readyResolver","_drawCallback","_canvasReady","Delete","SetMap","OnAdd","_canvas","style","position","left","top","SetCanvasElement","OnRemove","RemoveEventHandlers","Redraw","clear","Resize","UpdatePosition","w","h","BingLayer","_layer","_maps","AddListener","eventType","fn","Microsoft","Maps","Events","addHandler","AddEntity","entity","NativePrimitve","GetVisible","add","_pendingEntities","AddEntities","entities","isArray","eachSeries","nextTick","DeleteLayer","GetOptions","Number","getId","getVisible","RemoveEntity","remove","SetEntities","setPrimitives","SetOptions","options","metadata","SetVisible","visible","setVisible","splice","BingConversions","TranslateAction","action","eventHandler","label","TranslateActions","actions","a","TranslateBounds","box","LocationRect","fromEdges","maxLatitude","minLongitude","minLatitude","maxLongitude","TranslateClusterOptions","keys","filter","_clusterOptionsAttributes","indexOf","layerOffset","TranslatePoint","placementMode","ClusterPlacementMode","ClusterPlacementType","FirstLocation","MeanAverage","TranslateInfoBoxOptions","_infoWindowOptionsAttributes","pixelOffset","location","TranslateLocation","TranslateLoadOptions","_mapOptionsAttributes","_viewOptionsAttributes","center","mapTypeId","MapTypeId","labelOverlay","LabelOverlay","hidden","bounds","latlong","Location","TranslateMarkerOptions","_markerOptionsAttributes","anchor","TranslateOptions","TranslatePaths","paths","_p","point","Point","TranslatePolygonOptions","exec","z","substr","parseInt","_polygonOptionsAttributes","strokeThickness","strokeWeight","strokeOpacity","strokeColor","fillOpacity","fillColor","TranslatePolylineOptions","_polylineOptionsAttributes","TranslateViewOptions","centerOffset","BingMarker","_pushpin","_map","_isFirst","val","_isLast","l","getLocation","_metadata","DeleteMarker","GetLabel","getText","SetAnchor","setOptions","SetDraggable","draggable","SetIcon","SetLabel","SetPosition","latLng","setLocation","SetTitle","title","BingSpiderClusterMarker","BingClusterLayer","circleSpiralSwitchover","collapseClusterOnMapChange","collapseClusterOnNthClick","invokeClickOnHover","minCircleLength","minSpiralAngleSeperation","spiralDistanceFactor","stickStyle","stickHoverStyle","markerSelected","markerUnSelected","isMarker","IsFirst","StopClustering","_isClustering","getPushpins","setPushpins","_markers","_pendingMarkers","_markerLookup","IsLast","StartClustering","map","apply","_a","_b","InitializeSpiderClusterSupport","_useSpiderCluster","MapInstance","_spiderLayer","_currentZoom","getZoom","SetSpiderOptions","layers","insert","_events","OnMapClick","OnMapViewChangeStart","OnMapViewChangeEnd","OnLayerClick","OnSpiderMouseOver","OnSpiderMouseOut","MapPromise","then","removeHandler","_spiderMarkers","GetMarkerFromBingMarker","pin","getOptions","gridSize","clusteringEnabled","callback","clusteredPinCallback","zIndex","GetSpiderMarkerFromBingMarker","_spiderMarkerLookup","delete","spiderClusterOptions","GetBasicPushpinOptions","getAnchor","getColor","cursor","getCursor","getIcon","roundClickableArea","getRoundClickableArea","subTitle","getSubTitle","textOffset","getTextOffset","getTitle","HideSpiderCluster","_mapclicks","_currentCluster","_spiderOptions","primitive","ClusterPushpin","showNewCluster","ShowSpiderCluster","isClusterMarker","ParentMarker","ppin","hasHandler","invoke","hasZoomChanged","Pushpin","Stick","cluster","containedPushpins","pins","centerPoint","tryLocationToPixel","PixelReference","control","stick","angle","makeSpiral","legPixelLength","stepAngle","stepLength","len","loc","tryPixelToLocation","spiderMarker","BingInfoWindow","_infoBox","_isOpen","eventName","Close","GetPosition","Open","MapLabel","Set","SetValues","Changed","prop","shouldRunDrawCanvas","shouldRunDraw","DrawCanvas","Draw","minZoom","Get","maxZoom","undefined","GetMap","mapZoom","clearRect","strokeStyle","backgroundColor","textWidth","lineWidth","strokeText","fillRect","marginLeft","GetMarginLeft","marginTop","pointerEvents","parentNode","removeChild","Extender","obj","_obj","_proto","Extend","newObj","property","defineProperty","newProperty","BingMapLabel","_options","beneathLabels","fontFamily","fontColor","key","getMap","visibility","pos","lineJoin","setHtmlElement","OnLoad","BingPolygon","_polygon","_mapService","_originalPath","_maxZoom","ManageLabel","_minZoom","_showLabel","_showTooltip","ManageTooltip","_title","handlerId_1","_editingCompleteEmitter","_label","_tooltip","GetDraggable","GetEditable","_isEditable","getLocations","getRings","SetEditable","editable","isChanged","GetDrawingTools","t","edit","finish","editedPolygon","newPath","originalPath","SetPaths","Click","OriginalPath","NewPath","SetPath","setLocations","setRings","p_1","Centroid","align","_hasToolTipReceiver","_mouseOverListener","_tooltipVisible","_mouseMoveListener","_mouseOutListener","BingPolyline","_polyline","BingMapEventsLookup","click","dblclick","rightclick","resize","boundschanged","centerchanged","zoomchanged","mouseover","mouseout","mousemove","infowindowclose","BingCanvasOverlay","GetCoordinatesFromClick","GetToolTipOverlay","_zoomStart","_centerStart","getCenter","_viewChangeEvent","getMapTypeId","display","zoomCurrent","centerCurrent","pow","newWidth","getWidth","newHeight","getHeight","pixelPoints","centerOffsetX","centerOffsetY","_viewChangeEndEvent","UpdateCanvas","_mapResizeEvent","el","roadmap","satellite","terrain","GoogleConversions","east","north","south","west","TranslateInfoWindowOptions","content","description","lat","lng","TranslateLatLng","latlng","TranslateLocationObject","google","maps","LatLng","TranslateLatLngObject","TranslateLocationObjectArray","latlongArray","TranslateMapTypeId","GoogleMapTypes.MapTypeId","gestureHandling","zoomControl","mapTypeControl","styles","GoogleInfoWindow","_infoWindow","addListener","close","getPosition","open","setPosition","GoogleMarker","_marker","setMap","getLabel","setDraggable","setIcon","setLabel","setTitle","GoogleMapLabel","setValues","projection","getProjection","fromLatLngToDivPixel","panes","getPanes","overlayLayer","appendChild","GooglePolygon","getDraggable","getEditable","getPath","getPaths","previous","setEditable","setPath","setPaths","event","removeListener","GooglePolyline","GoogleMapEventsLookup","GoogleCanvasOverlay","OnDraw","getDiv","offsetWidth","offsetHeight","cc","Injectable","MapService","GetRandonLocations","count","_getRandomLocation","random","crossesDateLine","LayerService","EventEmitter","Directive","args","selector","Input","Output","infoBoxId","InfoBoxComponent","_infoBoxService","_content","nativeElement","innerText","trim","outerHTML","_id","InfoBoxClose","emit","ngAfterViewInit","AddInfoWindow","_infoBoxAddedToManager","HandleEvents","ngOnChanges","changes","Latitude","Longitude","currentValue","SetInfoWindowOptions","ngOnDestroy","DeleteInfoWindow","ToString","CreateEventObservable","subscribe","Title","Description","disableAutoPan","DisableAutoPan","Visible","xOffset","yOffset","Component","template","encapsulation","ViewEncapsulation","InfoBoxService","ViewChild","ContentChildren","InfoBoxActionDirective","markerId","MapMarkerDirective","_markerService","_containerRef","_markerAddedToManger","_inClusterLayer","_inCustomLayer","_layerId","LocationToPixel","LocationToPoint","ngAfterContentInit","HostMarker","element","parentElement","parentName","tagName","toLowerCase","attributes","AddMarker","AddEventListeners","UpdateMarkerPosition","UpdateTitle","UpdateLabel","UpdateDraggable","UpdateIcon","UpdateAnchor","UpdateVisible","unsubscribe","_getEventArg","Pixels","GetPixelsFromClick","_clickTimeout","timer","MarkerClick","DblClick","name","handler","ev","Drag","DragEnd","DragStart","MouseDown","MouseMove","MouseOut","MouseOver","MouseUp","RightClick","os","MarkerService","ViewContainerRef","ContentChild","MapComponent","_zone","_box","_longitude","_latitude","ConvertToDecimal","UpdateCenter","_zoom","SetZoom","ngOnInit","InitMapInstance","_container","_mapPromise","SetViewOptions","SetMapOptions","DisposeMap","TriggerResize","setTimeout","TriggerMapEvent","defaultValue","parseFloat","HandleMapClickEvents","SubscribeToMapEvent","MapClick","clearTimeout","MapDblClick","MapRightClick","MapMouseOver","MapMouseOut","MapMouseMove","HandleMapBoundsChange","GetBounds","BoundsChange","HandleMapCenterChange","GetCenter","CenterChange","HandleMapZoomChange","GetZoom","ZoomChange","runOutsideAngular","zoom","CreateMap","SetCenter","providers","provide","deps","MapServiceFactory","useFactory","MapServiceCreator","ClusterService","MarkerServiceFactory","InfoBoxServiceFactory","LayerServiceFactory","ClusterServiceFactory","PolygonService","PolygonServiceFactory","PolylineService","PolylineServiceFactory","changeDetection","ChangeDetectionStrategy","OnPush","NgZone","HostBinding","CreateClusterService","ma","CreateInfoBoxService","CreateLayerService","Create","CreateMarkerService","CreatePolygonService","CreatePolylineService","layerId","MapLayerDirective","_layerService","_visible","AddLayer","_addedToManager","GetNativeLayer","ClusterLayerDirective","ClusterClickAction","MAX_SAFE_INTEGER","_clusterClickAction","_clusteringEnabled","_clusterPlacementMode","_iconCreationCallback","_useDynamicSizeMarker","_dynamicMarkerBaseSize","_dynamicMarkerRanges","_gridSize","_iconInfo","_layerOffset","_minimumClusterSize","_spiderClusterOptions","_styles","info","CreateDynamicSizeMarker","_zIndex","_zoomOnClick","baseMarkerSize","ranges","mr","outline","total","log","v","svg","markerOffsetRatio","polygonId","MapPolygonDirective","_polygonService","_addedToService","AddPolygon","GeneratePolygonChangeSet","isFirstChange","UpdatePolygon","DeletePolygon","PathChanged","hasOptions","clickable","Clickable","Draggable","Editable","FillColor","FillOpacity","geodesic","Geodesic","labelMaxZoom","LabelMaxZoom","labelMinZoom","LabelMinZoom","showTooltip","ShowTooltip","showLabel","ShowLabel","StrokeColor","StrokeOpacity","StrokeWeight","polylineId","MapPolylineDirective","_polylineService","AddPolyline","GeneratePolylineChangeSet","UpdatePolyline","DeletePolyline","MapMarkerLayerDirective","_clusterService","_streaming","_markersLast","slice","fakeLayerDirective","Id","EnableClustering","LayerOffset","ZIndex","ClusteringEnabled","GridSize","IconInfo","ClusterIconInfo","CustomMarkerCallback","UseDynamicSizeMarkers","_layerPromise","_service","MarkerOptions","UpdateMarkers","shouldSetOptions","firstChange","zoomOnClick","markers","CreateMarkers","marker","MapPolygonLayerDirective","_polygons","_polygonsLast","all","CreateCanvasOverlay","DrawLabels","values","ShowTooltips","PolygonOptions","UpdatePolygons","_tooltipSubscriptions","PolygonClick","PolygonDblClick","PolygonMouseMove","PolygonMouseOut","PolygonMouseOver","ShowLabels","ctx_1","labels_1","_labels","LocationsToPoints","locs","MapSize","DrawText","lo","LabelOptions","DefaultLabelStyle","_defaultOptions","textAlign","show","asObservable","polygons","CreatePolygons","poly","MapPolylineLayerDirective","_polylines","_polylinesLast","PolylineOptions","UpdatePolylines","PolylineClick","PolylineDblClick","PolylineMouseMove","PolylineMouseOut","PolylineMouseOver","polylines","CreatePolylines","title_1","centroids_1","DocumentRef","GetNativeDocument","WindowRef","GetNativeWindow","window","HTTP","HTTPS","AUTO","ScriptProtocol","DEFAULT_CONFIGURATION","BingMapAPILoaderConfig","BingMapAPILoader","_config","_windowRef","_documentRef","Load","_scriptLoadingPromise","script","type","async","defer","callbackName","Date","getMilliseconds","GetScriptSrc","onerror","head","protocol","hostAndPath","queryParams","branch","decorators","Optional","MapAPILoader","BingInfoBoxService","InfoWindowActions","Label","ActionClicked","HtmlContent","htmlContent","infoPromise","CreateInfoWindow","_boxes","infoComponent","eventNameTranslated","Observable","observer","run","CloseInfoBoxesOnOpen","Modal","IsOpen","BingMarkerService","IconUrl","isFirst","IsFirstInSet","isLast","IsLastInSet","Width","Height","Anchor","Metadata","markerPromise","InClusterLayer","LayerId","InCustomLayer","DynamicMarkerCreated","Subject","GetNativeMarker","target","payload","BingMapService","_loader","_mapResolver","Config","_modules","_mapInstance","overlay","CreateClusterLayer","LoadModule","bl","layer","ClusterLayer","infoBox","Infobox","CreateLayer","mapOptions","MixinMapLabelWithOverlayView","CustomOverlay","MixinCanvasOverlay","credentials","apiKey","pushpin","CreatePolygon","CreatePolyline","polyline","pl_1","lines_1","pl","dispose","getBounds","getNorth","crossesInternationalDateLine","getWest","getEast","getSouth","padding","useSharedInstance","LoadModuleInstance","moduleName","loadModule","lastIndexOf","setView","BingLayerBase","GetLayerById","markerIcon","op","mo","_layers","l1","BingLayerService","layerPromise","polygon","line","polyline_1","lines_2","BingClusterService","CreateClusterPushPin","CreateCustomClusterPushPin","SpiderClusterOptions","o_1","payload_1","ico","bounds_1","locs_1","fromLocations","BingPolygonService","polygonPromise","Paths","GetNativePolygon","BingPolylineService","polylinePromise","Path","GetNativePolyline","index","BingMapServiceFactory","BingMapServiceFactoryFactory","apiLoader","zone","BingMapLoaderFactory","GoogleLayerBase","mp","lp","GoogleClusterService","CreateClusterIcons","pa","MinimumClusterSize","minimumClusterSize","Styles","textColor","textSize","backgroundPosition","resetStyles","clusterer","_layerStyles","setStyles","setCalculator","GoogleInfoBoxService","infoWindowPromise","googleEventName","GoogleLayer","_entities","GoogleLayerService","p1_1","__values","TypeError","tslib_1.__values","p1_1_1","GoogleMapAPILoaderConfig","GoogleMapAPILoader","GetMapsScriptSrc","enableClustering","clusterScript","GetClusterScriptSrc","onreadystatechange","apiVersion","client","clientId","channel","libraries","region","language","clusterHostAndPath","entry","GoogleMarkerService","getSouthWest","getNorthEast","offsetY","fromLatLngToPoint","offsetX","floor","GoogleMarkerClusterer","addMarker","addMarkers","getMarkers","clearMarkers","GetMarkerFromGoogleMarker","getGridSize","getMaxZoom","getMinClusterSize","isAverageCenter","isZoomOnClick","getStyles","removeMarker","setMinClusterSize","resetViewport","redraw","setGridSize","setMaxZoom","p_2","GoogleMapService","updateOptions","markerClusterer","MarkerClusterer","clusterLayer","infoWindow","MixinMapLabelWithOverlayView$1","OverlayView","MixinCanvasOverlay$1","fitBounds","max","min","ll","setCenter","setZoom","trigger","GooglePolygonService","GooglePolylineService","GoogleMapServiceFactory","GoogleMapServiceFactoryFactory","GoogleMapLoaderFactory","MapModule","forRoot","mapServiceFactory","loader","ngModule","useValue","forRootBing","forRootGoogle","NgModule","declarations","imports","CommonModule","exports"],"mappings":"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GhB,gBAI9D,CACDiC,EAAEsI,MAAQ,IAAI7I,MAGd,IADMhB,EAAsBqG,EAAa,MAChChG,EAAI,EAAGA,EAAIL,EAAGI,OAAQC,IAC3BkB,EAAEsI,MAAMxJ,GAAK,CAACkc,IAAKvc,EAAGK,GAAGhB,SAAUmd,IAAKxc,EAAGK,GAAGf,iBAKtDiC,EAAEpB,GAAK,EAAeA,KAG3BoB,GAWGwa,EAAAlR,kCAAyBxE,GACnC,IAAM9E,EAA0C,GAMhD,OALAV,OAAO+G,KAAKvB,GACPwB,OAAO,SAAA1H,GAAK,OAA6D,IAA7D4b,EAAkBjR,2BAA2B/C,QAAQ5H,KACjErE,QAAQ,SAACqE,GACNoB,EAAEpB,GAAK,EAAeA,KAEvBoB,2BAlasC,CAC7C,kBACA,SACA,iBACA,uBACA,mBACA,yBACA,YACA,kBACA,iBACA,iBACA,oBACA,2BACA,kBACA,UACA,oBACA,iBACA,wBACA,YACA,UACA,UACA,UACA,aACA,oBACA,gBACA,uBACA,eACA,sBACA,cACA,sBACA,aACA,oBACA,2BACA,SACA,OACA,OACA,cACA,qDAQoD,CACpD,UACA,cACA,cACA,KACA,WACA,cACA,kBACA,cACA,UACA,QACA,oBACA,WACA,UACA,QACA,qCAQgD,CAChD,SACA,WACA,QACA,OACA,QACA,YACA,OACA,QACA,SACA,WACA,WACA,uCAQiD,CACjD,WACA,uBACA,oBACA,WACA,cACA,gBACA,UACA,sCAQiD,CACjD,YACA,YACA,WACA,YACA,cACA,WACA,QACA,cACA,gBACA,eACA,UACA,uCAQkD,CAClD,YACA,YACA,WACA,WACA,cACA,gBACA,eACA,UACA,eCrJRic,EAAA,WAmCI,SAAAA,EAAoBC,EAAgD7G,GAAhD5X,KAAAye,YAAAA,EAAgDze,KAAA4X,YAAAA,+BAzBzD4G,EAAAze,UAAA,SAAM,gBACb,OAAqB,IAAjBC,KAAKoU,+DAUFoK,EAAAze,UAAA,iBAAc,gBACrB,OAAOC,KAAKye,6CA4BTD,EAAAze,UAAA0F,qBAAYC,EAAmBC,cAClC3F,KAAKye,YAAYC,YAAYhZ,EAAW,SAAC7C,GACn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","sourcesContent":["import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\n\r\nexport abstract class InfoWindow {\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get IsOpen(): boolean;\r\n\r\n    /**\r\n     * Get the underlying native primitive of the implementation.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Adds an event listener to the info window.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Close(): void ;\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @abstract\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract GetPosition(): ILatLong;\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Open(): void;\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @abstract\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetOptions(options: IInfoWindowOptions): void;\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @abstract\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetPosition(position: ILatLong): void;\r\n}\r\n","export enum MarkerTypeId {\r\n    None = 0,\r\n    FontMarker,\r\n    CanvasMarker,\r\n    DynamicCircleMarker,\r\n    RotatedImageMarker,\r\n    RoundedImageMarker,\r\n    ScaledImageMarker,\r\n    Custom\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { MarkerTypeId } from '../models/marker-type-id';\r\n\r\n/**\r\n * This interface defines the contract for an icon cache entry.\r\n */\r\ninterface IMarkerIconCacheEntry {\r\n    /**\r\n     * The icon string of the cache entry.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n     */\r\n    markerIconString: string;\r\n\r\n    /**\r\n     * The Size of the icon.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n    * */\r\n    markerSize: ISize;\r\n}\r\n\r\n/**\r\n * This class defines the contract for a marker.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n\r\n    /**\r\n     * Caches concrete img elements for marker icons to accelerate patining.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static ImageElementCache: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();\r\n\r\n\r\n    /**\r\n     * Used to cache generated markers for performance and reusability.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static MarkerCache: Map<string, IMarkerIconCacheEntry> = new Map<string, IMarkerIconCacheEntry>();\r\n\r\n    /**\r\n     * Creates a marker based on the marker info. In turn calls a number of internal members to\r\n     * create the actual marker.\r\n     *\r\n     * @param iconInfo - icon information. Depending on the marker type, various properties\r\n     * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate\r\n     * reuse.\r\n     * @param callback - a callback that is invoked on markers that require asyncronous\r\n     * processing during creation. For markers that do not require async processing, this parameter is ignored.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image.\r\n     * @memberof Marker\r\n     */\r\n    public static CreateMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        switch (iconInfo.markerType) {\r\n            case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);\r\n            case MarkerTypeId.DynamicCircleMarker: return Marker.CreateDynamicCircleMarker(iconInfo);\r\n            case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);\r\n            case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);\r\n            case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);\r\n            case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);\r\n            case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');\r\n        }\r\n        throw Error('Unsupported marker type: ' + iconInfo.markerType);\r\n    }\r\n\r\n    /**\r\n     * Obtains a shared img element for a marker icon to prevent unecessary creation of\r\n     * DOM items. This has sped up large scale makers on Bing Maps by about 70%\r\n     * @param icon - The icon string (url, data url, svg) for which to obtain the image.\r\n     * @returns - The obtained image element.\r\n     * @memberof Marker\r\n     */\r\n    public static GetImageForMarker(icon: string): HTMLImageElement {\r\n        if (icon == null || icon === '' ) { return  null; }\r\n\r\n        let img: HTMLImageElement = null;\r\n        img = Marker.ImageElementCache.get(icon);\r\n        if (img != null) { return img; }\r\n\r\n        if (typeof(document) !== 'undefined' && document != null) {\r\n            img = document.createElement('img');\r\n            img.src = icon;\r\n            Marker.ImageElementCache.set(icon, img);\r\n        }\r\n        return img;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvased based marker using the point collection contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateCanvasMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for canvas markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {\r\n            throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        c.width = iconInfo.size.width;\r\n        c.height = iconInfo.size.height;\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        // Draw a path in the shape of an arrow.\r\n        ctx.beginPath();\r\n        if (iconInfo.drawingOffset) { ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y); }\r\n        iconInfo.points.forEach((p: IPoint) => { ctx.lineTo(p.x, p.y); });\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a circle marker image using information contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateDynamicCircleMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for dynamic circle markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null) { throw Error('IMarkerIconInfo.size is required for dynamic circle markers.'); }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const strokeWidth: number = iconInfo.strokeWidth || 0;\r\n        // Create an SVG string of a circle with the specified radius and color.\r\n        const svg: Array<string> = [\r\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\" height=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\"><circle cx=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" cy=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" r=\"',\r\n            ((iconInfo.size.width / 2) - strokeWidth).toString(),\r\n            '\" stroke=\"',\r\n            iconInfo.color || 'red',\r\n            '\" stroke-width=\"',\r\n            strokeWidth.toString(),\r\n            '\" fill=\"',\r\n            iconInfo.color || 'red',\r\n            '\"/></svg>'\r\n        ];\r\n\r\n        const s: string = svg.join('');\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateFontBasedMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for font based markers'); }\r\n        if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {\r\n            throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        const font: string = iconInfo.fontSize + 'px ' + iconInfo.fontName;\r\n        ctx.font = font;\r\n\r\n        // Resize canvas based on sie of text.\r\n        const size: TextMetrics = ctx.measureText(iconInfo.text);\r\n        c.width = size.width;\r\n        c.height = iconInfo.fontSize;\r\n\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        // Reset font as it will be cleared by the resize.\r\n        ctx.font = font;\r\n        ctx.textBaseline = 'top';\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        ctx.fillText(iconInfo.text, 0, 0);\r\n        iconInfo.size = { width: c.width, height: c.height };\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates an image marker by applying a roation to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRotatedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rotated image markers'); }\r\n        if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const image: HTMLImageElement = new Image();\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            if (iconInfo.size) {\r\n                image.width = iconInfo.size.width;\r\n                image.height = iconInfo.size.height;\r\n            }\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                const rads: number = iconInfo.rotation * Math.PI / 180;\r\n\r\n                // Calculate rotated image size.\r\n                c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));\r\n                c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));\r\n\r\n                // Move to the center of the canvas.\r\n                ctx.translate(c.width / 2, c.height / 2);\r\n                // Rotate the canvas to the specified angle in degrees.\r\n                ctx.rotate(rads);\r\n                // Draw the image, since the context is rotated, the image will be rotated also.\r\n                ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a rounded image marker by applying a circle mask to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRoundedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rounded image markers'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const radius: number = iconInfo.size.width / 2;\r\n            const image: HTMLImageElement = new Image();\r\n            const offset: IPoint = iconInfo.drawingOffset || { x: 0, y: 0 };\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = iconInfo.size.width;\r\n                c.height = iconInfo.size.width;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.beginPath();\r\n                ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);\r\n                ctx.fill();\r\n                ctx.clip();\r\n                ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateScaledImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for scaled image markers'); }\r\n        if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const image: HTMLImageElement = new Image();\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = image.width * iconInfo.scale;\r\n                c.height = image.height * iconInfo.scale;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.drawImage(image, 0, 0, c.width, c.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsFirst(): boolean;\r\n    public abstract set IsFirst(val: boolean);\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsLast(): boolean;\r\n    public abstract set IsLast(val: boolean);\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Location(): ILatLong;\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker (e.g. Microsoft.Maps.Pushpin)\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract DeleteMarker(): void;\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetLabel(): string;\r\n\r\n    /**\r\n     * Gets the marker visibility\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetAnchor(anchor: IPoint): void;\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetIcon(icon: string): void;\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetLabel(label: string): void;\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetPosition(latLng: ILatLong): void;\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetTitle(title: string): void;\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetOptions(options: IMarkerOptions): void;\r\n\r\n    /**\r\n     * Sets the visiblilty of the marker.\r\n     *\r\n     * @abstract\r\n     * @param visible - Boolean which determines if the marker is visible or not.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","export enum MapTypeId {\r\n\r\n    /** The aerial map type which uses top-down satellite & airplane imagery. */\r\n    aerial,\r\n\r\n    /** A darker version of the road maps. */\r\n    canvasDark,\r\n\r\n    /** A lighter version of the road maps which also has some of the details such as hill shading disabled. */\r\n    canvasLight,\r\n\r\n    /** A grayscale version of the road maps. */\r\n    grayscale,\r\n\r\n    /** The aerial map type including lables */\r\n    hybrid,\r\n\r\n    /** Displays a blank canvas that uses the mercator map project. It basically removed the base maps layer. */\r\n    mercator,\r\n\r\n    /** Ordnance survey map type (en-gb only). */\r\n    ordnanceSurvey,\r\n\r\n    /** Road map type. */\r\n    road,\r\n\r\n    /** Provides streetside panoramas from the street level. */\r\n    streetside\r\n\r\n}\r\n","import { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { Marker } from './marker';\r\nimport { Polygon } from './polygon';\r\nimport { Polyline } from './polyline';\r\nimport { InfoWindow } from './info-window';\r\n\r\n/**\r\n * Defines the contract for a map layer implementation. Deriving providers should implements this abstract\r\n * to provide concrete layer functionality for the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Layer {\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns - An object representing the native implementation of the layer in the underlying provider (such as\r\n     * Microsoft.Maps.Layer).\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Adds an entity to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * these concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntities(entity: Array<Marker|InfoWindow|Polygon|Polyline>): void;\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns - The layer options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetOptions(): ILayerOptions;\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns - True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n     /**\r\n     * Removes an entity from the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n     /**\r\n     * Sets the entities for the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void;\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetOptions(options: ILayerOptions): void;\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     * @abstract\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polygon in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polygon {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polygon's center.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon's centroid.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolygonCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMaxZoom(): number;\r\n    public abstract set LabelMaxZoom(val: number);\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMinZoom(): number;\r\n    public abstract set LabelMinZoom(val: number);\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowLabel(): boolean;\r\n    public abstract set ShowLabel(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polygon\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polygon path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of Array of ILatLong objects describing multiple polygon paths.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPaths(): Array<Array<ILatLong>>;\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetOptions(options: IPolygonOptions): void;\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @abstract\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polygons' bounding box.\r\n     *\r\n     * @returns - ILatLong object containing the center of the bounding box.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        if (path) {\r\n            path.forEach(inner => inner.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            }));\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polygon based on the polygon path.\r\n     *\r\n     * @returns - The centroid coordinates of the polygon.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolygonCentroid(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        const off = path[0][0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n            for (let k = 0; k < path.length; k++) {\r\n                for (let i = 0, j = path[k].length - 1; i < path[k].length; j = i++) {\r\n                    p1 = path[k][i];\r\n                    p2 = path[k][j];\r\n                    f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                        (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                    twicearea += f;\r\n                    x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                    y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n                }\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polyline in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polyline {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline's center.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline's centroid.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolylineCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polylin\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the a path.\r\n     *\r\n     * @param path - the path for which to generate the centroid\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     */\r\n    public static GetPolylineCentroid(path: Array<ILatLong>): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const off = path[0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n\r\n            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {\r\n                p1 = path[i];\r\n                p2 = path[j];\r\n                f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                    (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                twicearea += f;\r\n                x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetOptions(options: IPolylineOptions): void;\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polyline' bounding box.\r\n     *\r\n     * @returns - {@link ILatLong} object containing the center of the bounding box.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        if (path) {\r\n            path.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            });\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the polyline path.\r\n     *\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolylineCentroid(): ILatLong {\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        const c: ILatLong  = Polyline.GetPolylineCentroid(path);\r\n        return c;\r\n    }\r\n\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Marker } from './marker';\r\n\r\nexport abstract class SpiderClusterMarker extends Marker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: Marker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: any;\r\n\r\n}\r\n","export enum ClusterPlacementMode {\r\n    None = 0,\r\n    MeanValue,\r\n    FirstPin\r\n}\r\n","export enum ClusterClickAction {\r\n    None = 0,\r\n    ZoomIntoCluster,\r\n    Spider\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { MapLabel } from './map-label';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Abstract base implementing a canvas overlay to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    protected _readyResolver: (val: boolean) => void;\r\n    protected _canvas: HTMLCanvasElement;\r\n    protected _zoomStart: number;\r\n    protected _centerStart: ILatLong;\r\n    public _canvasReady: Promise<boolean> = new Promise<boolean>((resolve, reject) => { this._readyResolver = resolve; });\r\n\r\n    /**\r\n     * Returns a promise that gets resolved when the canvas overlay is ready for interaction.\r\n     */\r\n    public get CanvasReady(): Promise<boolean> { return this._canvasReady; }\r\n\r\n    /**\r\n    * A callback function that is triggered when the canvas is ready to be rendered for the current map view.\r\n    */\r\n    private _drawCallback: (canvas: HTMLCanvasElement) => void;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the CanvasOverlay class.\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        this._drawCallback = drawCallback;\r\n        id++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the canvas overlay.\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: any): ILatLong;\r\n\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     */\r\n    public abstract GetToolTipOverlay(): MapLabel;\r\n\r\n    /**\r\n     * CanvasOverlay added to map, load canvas.\r\n     */\r\n    public OnAdd(): void {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.style.position = 'absolute';\r\n        this._canvas.style.left = '0px';\r\n        this._canvas.style.top = '0px';\r\n        this._canvas.id = `xMapOverlay${id}`;\r\n\r\n        // Add the canvas to the overlay.\r\n        this.SetCanvasElement(this._canvas);\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof CanvasOverlay\r\n     */\r\n    public abstract OnLoad(): void;\r\n\r\n    /**\r\n     * When the CanvasLayer is removed from the map, release resources.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public OnRemove(): void {\r\n        this.SetCanvasElement(null);\r\n        this.RemoveEventHandlers();\r\n        this._canvas = null;\r\n    }\r\n\r\n    /**\r\n     * Redraws the canvas for the current map view.\r\n     * @param clear - True to clear the canvas before drawing.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public Redraw(clear: boolean): void {\r\n        if (this._canvas == null) { return; }\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        if (clear) { this.Resize(); }\r\n\r\n        // Call the drawing callback function if specified.\r\n        if (this._drawCallback) {\r\n            this._drawCallback(this._canvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected abstract SetCanvasElement(el: HTMLCanvasElement): void;\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract RemoveEventHandlers(): void;\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract Resize(): void;\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract UpdateCanvas(): void;\r\n\r\n    /**\r\n     * Simple function for updating the CSS position and dimensions of the canvas.\r\n     * @param x The horizontal offset position of the canvas.\r\n     * @param y The vertical offset position of the canvas.\r\n     * @param w The width of the canvas.\r\n     * @param h The height of the canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdatePosition(x: number, y: number, w: number, h: number) {\r\n        // Update CSS position.\r\n        this._canvas.style.left = x + 'px';\r\n        this._canvas.style.top = y + 'px';\r\n\r\n        // Update CSS dimensions.\r\n        this._canvas.style.width = w + 'px';\r\n        this._canvas.style.height = h + 'px';\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService} from '../../services/map.service';\r\n\r\n/**\r\n * Concrete implementation of a map layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingLayer implements Layer {\r\n\r\n    private _pendingEntities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.Layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.Layer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity && entity.NativePrimitve) {\r\n            if (this.GetVisible()) {\r\n                this._layer.add(entity.NativePrimitve);\r\n            }\r\n            else {\r\n                this._pendingEntities.push(entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        //\r\n        // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.\r\n        //\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            eachSeries([...entities], (e, next) => {\r\n                if (this.GetVisible()) {\r\n                    this._layer.add(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingEntities.push(e);\r\n                }\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public Delete(): void {\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const o: ILayerOptions = {\r\n            id: Number(this._layer.getId())\r\n        };\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetVisible(): boolean  {\r\n        return this._layer.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._layer.remove(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void {\r\n        //\r\n        // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...\r\n        //\r\n        this._layer.setPrimitives([]);\r\n        this.AddEntities(entities);\r\n\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions) {\r\n        this._layer.metadata.id = options.id.toString();\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._layer.setVisible(visible);\r\n        if (visible && this._pendingEntities.length > 0) {\r\n            this.AddEntities(this._pendingEntities.splice(0));\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from '../../interfaces/iinfo-window-action';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { ClusterPlacementMode } from '../../models/cluster-placement-mode';\r\nimport { BingMapService } from './bing-map.service';\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Bing Maps V8 specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class BingConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'credentials',\r\n        'customizeOverlays',\r\n        'customMapStyle',\r\n        'disableBirdseye',\r\n        'disableKeyboardInput',\r\n        'disableMouseInput',\r\n        'disablePanning',\r\n        'disableTouchInput',\r\n        'disableUserInput',\r\n        'disableZooming',\r\n        'disableStreetside',\r\n        'enableClickableLogo',\r\n        'enableSearchLogo',\r\n        'fixedMapPosition',\r\n        'height',\r\n        'inertiaIntensity',\r\n        'navigationBarMode',\r\n        'showBreadcrumb',\r\n        'showCopyright',\r\n        'showDashboard',\r\n        'showMapTypeSelector',\r\n        'showScalebar',\r\n        'theme',\r\n        'tileBuffer',\r\n        'useInertia',\r\n        'width',\r\n        'center',\r\n        'zoom',\r\n        'mapTypeId',\r\n        'liteMode'\r\n    ];\r\n\r\n    /**\r\n     * View option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _viewOptionsAttributes: string[] = [\r\n        'animate',\r\n        'bounds',\r\n        'center',\r\n        'centerOffset',\r\n        'heading',\r\n        'labelOverlay',\r\n        'mapTypeId',\r\n        'padding',\r\n        'zoom'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'draggable',\r\n        'height',\r\n        'htmlContent',\r\n        'icon',\r\n        'infobox',\r\n        'state',\r\n        'title',\r\n        'textOffset',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Bing Map Polygon properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Bing Map Polyline properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param action - Object to be mapped.\r\n     * @returns - Navtive mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateAction(action: IInfoWindowAction): Microsoft.Maps.IInfoboxActions {\r\n        const a: Microsoft.Maps.IInfoboxActions = {\r\n            eventHandler: action.eventHandler,\r\n            label: action.label\r\n        };\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param actions - Array of objects to be mapped.\r\n     * @returns - Array of mapped objects.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateActions(actions: Array<IInfoWindowAction>): Array<Microsoft.Maps.IInfoboxActions> {\r\n        const a: Array<Microsoft.Maps.IInfoboxActions> = new Array<Microsoft.Maps.IInfoboxActions>();\r\n        actions.forEach(x => a.push(BingConversions.TranslateAction(x)));\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an IBox object to a Microsoft.Maps.LocationRect object.\r\n     *\r\n     * @param box - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateBounds(box: IBox): Microsoft.Maps.LocationRect {\r\n        const r: Microsoft.Maps.LocationRect =\r\n            Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateClusterOptions(options: IClusterOptions): Microsoft.Maps.IClusterLayerOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._clusterOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'layerOffset') {\r\n                    o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);\r\n                }\r\n                if (k === 'placementMode') {\r\n                    if (options.placementMode === ClusterPlacementMode.FirstPin) {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;\r\n                    }\r\n                    else {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateInfoBoxOptions(options: IInfoWindowOptions): Microsoft.Maps.IInfoboxOptions {\r\n        const o: Microsoft.Maps.IInfoboxOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'pixelOffset') {\r\n                    o.offset = BingConversions.TranslatePoint(options.pixelOffset);\r\n                }\r\n                else if (k === 'position') {\r\n                    o.location = BingConversions.TranslateLocation(options.position);\r\n                }\r\n                else if (k === 'actions') {\r\n                    o.actions = BingConversions.TranslateActions(options.actions);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLoadOptions(options: IMapOptions): Microsoft.Maps.IMapLoadOptions {\r\n        const o: Microsoft.Maps.IMapLoadOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => {\r\n                return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;\r\n            })\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    if (options.mapTypeId === MapTypeId.hybrid) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;\r\n                    }\r\n                    else if (options.mapTypeId === MapTypeId.aerial) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;\r\n                    }\r\n                    else {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                    }\r\n                }\r\n                else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a Microsoft.Maps.Location object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): Microsoft.Maps.Location {\r\n        const l: Microsoft.Maps.Location = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - The mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): Microsoft.Maps.IPushpinOptions {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'anchor') {\r\n                    o.anchor = BingConversions.TranslatePoint(options.anchor);\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): Microsoft.Maps.IMapOptions {\r\n        const o: Microsoft.Maps.IMapOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<Microsoft.Maps.Location>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<Microsoft.Maps.Location>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // us for loop for performance\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                for (let j = 0; j < p1[i].length; j++) {\r\n                    _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));\r\n                }\r\n                p.push(_p);\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            const y: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            const p1 = <Array<ILatLong>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));\r\n            }\r\n            p.push(y);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPoint object to a Microsoft.Maps.Point object.\r\n     *\r\n     * @param point - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePoint(point: IPoint): Microsoft.Maps.Point {\r\n        const p: Microsoft.Maps.Point = new Microsoft.Maps.Point(point.x, point.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): Microsoft.Maps.IPolygonOptions {\r\n        const o: Microsoft.Maps.IPolygonOptions = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                }\r\n                else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {}\r\n                else if (k === 'fillColor') {\r\n                    if (options.fillOpacity) {\r\n                        o.fillColor = f(options.fillColor, options.fillOpacity);\r\n                    }\r\n                    else {\r\n                        o.fillColor = options.fillColor;\r\n                    }\r\n                }\r\n                else if (k === 'fillOpacity') {}\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): Microsoft.Maps.IPolylineOptions {\r\n        const o: Microsoft.Maps.IPolylineOptions | any = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                } else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateViewOptions(options: IMapOptions): Microsoft.Maps.IViewOptions {\r\n        const o: Microsoft.Maps.IViewOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._viewOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                } else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                } else if (k === 'centerOffset') {\r\n                    o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);\r\n                } else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../marker';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingMarker implements Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: Microsoft.Maps.Location = this._pushpin.getLocation();\r\n        return {\r\n            latitude: l.latitude,\r\n            longitude: l.longitude\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): any { return this._pushpin; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarker.\r\n     * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    constructor(private _pushpin: Microsoft.Maps.Pushpin, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._pushpin, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        if (!this._map && !this._layer) { return; }\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._pushpin.getText();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._pushpin.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetAnchor(anchor: IPoint): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.draggable = draggable;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.icon = icon;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.text = label;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: Microsoft.Maps.Location = BingConversions.TranslateLocation(latLng);\r\n        this._pushpin.setLocation(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.title = title;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: Microsoft.Maps.IPushpinOptions =  BingConversions.TranslateMarkerOptions(options);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.visible = visible;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n}\r\n","import { BingMarker } from './bing-marker';\r\nimport { SpiderClusterMarker } from '../spider-cluster-marker';\r\n\r\nexport class BingSpiderClusterMarker extends BingMarker implements SpiderClusterMarker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: BingMarker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: Microsoft.Maps.Polyline;\r\n\r\n}\r\n","import { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from '../../interfaces/ispider-cluster-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingSpiderClusterMarker } from './bing-spider-cluster-marker';\r\nimport { BingMarker } from './bing-marker';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingClusterLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _markerLookup: Map<Microsoft.Maps.Pushpin, Marker> = new Map<Microsoft.Maps.Pushpin, Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _spiderMarkers: Array<BingSpiderClusterMarker> = new Array<BingSpiderClusterMarker>();\r\n    private _spiderMarkerLookup: Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker> =\r\n                     new Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker>();\r\n    private _useSpiderCluster = false;\r\n    private _mapclicks = 0;\r\n    private _spiderLayer: Microsoft.Maps.Layer;\r\n    private _events: Array<Microsoft.Maps.IHandlerId> = new Array<Microsoft.Maps.IHandlerId>();\r\n    private _currentZoom = 0;\r\n    private _spiderOptions: ISpiderClusterOptions = {\r\n        circleSpiralSwitchover: 9,\r\n        collapseClusterOnMapChange: false,\r\n        collapseClusterOnNthClick: 1,\r\n        invokeClickOnHover: true,\r\n        minCircleLength: 60,\r\n        minSpiralAngleSeperation: 25,\r\n        spiralDistanceFactor: 5,\r\n        stickStyle: {\r\n            strokeColor: 'black',\r\n            strokeThickness: 2\r\n        },\r\n        stickHoverStyle: { strokeColor: 'red' },\r\n        markerSelected: null,\r\n        markerUnSelected: null\r\n    };\r\n    private _currentCluster: Microsoft.Maps.ClusterPushpin = null;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.ClusterLayer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.ClusterLayer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof BingMarker || isMarker;\r\n        if (isMarker) {\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(entity.NativePrimitve);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<Microsoft.Maps.Pushpin> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(...e);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the\r\n     * individual underlying pins.\r\n     *\r\n     * @param options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public InitializeSpiderClusterSupport(options?: ISpiderClusterOptions): void {\r\n        if (this._useSpiderCluster) { return; }\r\n        const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n        this._useSpiderCluster = true;\r\n        this._spiderLayer = new Microsoft.Maps.Layer();\r\n        this._currentZoom = m.getZoom();\r\n        this.SetSpiderOptions(options);\r\n        m.layers.insert(this._spiderLayer);\r\n\r\n        ///\r\n        /// Add spider related events....\r\n        ///\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', e => this.OnMapClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', e => this.OnMapViewChangeStart(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', e => this.OnMapViewChangeEnd(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', e => this.OnSpiderMouseOver(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', e => this.OnSpiderMouseOut(e)));\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public Delete(): void {\r\n        if (this._useSpiderCluster) {\r\n            this._spiderLayer.clear();\r\n            (<BingMapService>this._maps).MapPromise.then(m => {\r\n                m.layers.remove(this._spiderLayer);\r\n                this._spiderLayer = null;\r\n            });\r\n            this._events.forEach(e => Microsoft.Maps.Events.removeHandler(e));\r\n            this._events.splice(0);\r\n            this._useSpiderCluster = false;\r\n        }\r\n        this._markers.splice(0);\r\n        this._spiderMarkers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: o.gridSize,\r\n            layerOffset: o.layerOffset,\r\n            clusteringEnabled: o.clusteringEnabled,\r\n            callback: o.callback,\r\n            clusteredPinCallback: o.clusteredPinCallback,\r\n            visible: o.visible,\r\n            zIndex: o.zIndex\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._layer.getOptions().visible;\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns - The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetSpiderMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): BingSpiderClusterMarker {\r\n        const m: BingSpiderClusterMarker = this._spiderMarkerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker - Entity to be removed from the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                const i: number = p.indexOf(entity.NativePrimitve);\r\n                if (i > -1) {\r\n                    p.splice(i, 1);\r\n                    this._layer.setPushpins(p);\r\n                }\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.splice(0);\r\n        this._markerLookup.clear();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                this._markers.push(e);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n        this._layer.setOptions(o);\r\n        if (options.spiderClusterOptions) { this.SetSpiderOptions(options.spiderClusterOptions); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        o.visible = visible;\r\n        this._layer.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._pendingMarkers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n        this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates a copy of a pushpins basic options.\r\n     *\r\n     * @param pin Pushpin to copy options from.\r\n     * @returns - A copy of a pushpins basic options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private GetBasicPushpinOptions(pin: Microsoft.Maps.Pushpin): Microsoft.Maps.IPushpinOptions {\r\n        return <Microsoft.Maps.IPushpinOptions>{\r\n            anchor: pin.getAnchor(),\r\n            color: pin.getColor(),\r\n            cursor: pin.getCursor(),\r\n            icon: pin.getIcon(),\r\n            roundClickableArea: pin.getRoundClickableArea(),\r\n            subTitle: pin.getSubTitle(),\r\n            text: pin.getText(),\r\n            textOffset: pin.getTextOffset(),\r\n            title: pin.getTitle()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Hides the spider cluster and resotres the original pin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private HideSpiderCluster(): void {\r\n        this._mapclicks = 0;\r\n        if (this._currentCluster) {\r\n            this._spiderLayer.clear();\r\n            this._spiderMarkers.splice(0);\r\n            this._spiderMarkerLookup.clear();\r\n            this._currentCluster = null;\r\n            this._mapclicks = -1;\r\n            if (this._spiderOptions.markerUnSelected) { this._spiderOptions.markerUnSelected(); }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Click event handler for when a shape in the cluster layer is clicked.\r\n     *\r\n     * @param e The mouse event argurment from the click event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnLayerClick(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {\r\n            const cp: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.primitive;\r\n            const showNewCluster: boolean = cp !== this._currentCluster;\r\n            this.HideSpiderCluster();\r\n            if (showNewCluster) {\r\n                this.ShowSpiderCluster(<Microsoft.Maps.ClusterPushpin>e.primitive);\r\n            }\r\n        } else {\r\n            const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n            if (pin.metadata && pin.metadata.isClusterMarker) {\r\n                const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (this._spiderOptions.markerSelected) {\r\n                    this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));\r\n                }\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n                this._mapclicks = 0;\r\n            } else {\r\n                if (this._spiderOptions.markerSelected) { this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null); }\r\n                if (Microsoft.Maps.Events.hasHandler(pin, 'click')) { Microsoft.Maps.Events.invoke(pin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the click event on the map (outside a spider cluster). Depending on the\r\n     * spider options, closes the cluster or increments the click counter.\r\n     *\r\n     * @param e - Mouse event\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapClick(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._mapclicks === -1) {\r\n            return;\r\n        } else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {\r\n            this.HideSpiderCluster();\r\n        } else {\r\n            // do nothing as this._mapclicks has already been incremented above\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeEnd(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        const z: number = (<Microsoft.Maps.Map>e.target).getZoom();\r\n        const hasZoomChanged: boolean = (z !== this._currentZoom);\r\n        this._currentZoom = z;\r\n        if (hasZoomChanged) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view change start event. Depending on the spider options, hides the\r\n     * the exploded spider or does nothing.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeStart(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._spiderOptions.collapseClusterOnMapChange) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOut(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickStyle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event\r\n     * on the underlying original marker dependent on the spider options.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOver(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickHoverStyle);\r\n            if (this._spiderOptions.invokeClickOnHover) {\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the options for spider behavior.\r\n     *\r\n     * @param options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private SetSpiderOptions(options: ISpiderClusterOptions): void {\r\n        if (options) {\r\n            if (typeof options.circleSpiralSwitchover === 'number') {\r\n                this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;\r\n            }\r\n            if (typeof options.collapseClusterOnMapChange === 'boolean') {\r\n                this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;\r\n            }\r\n            if (typeof options.collapseClusterOnNthClick === 'number') {\r\n                this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;\r\n            }\r\n            if (typeof options.invokeClickOnHover === 'boolean') {\r\n                this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;\r\n            }\r\n            if (typeof options.minSpiralAngleSeperation === 'number') {\r\n                this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;\r\n            }\r\n            if (typeof options.spiralDistanceFactor === 'number') {\r\n                this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;\r\n            }\r\n            if (typeof options.minCircleLength === 'number') {\r\n                this._spiderOptions.minCircleLength = options.minCircleLength;\r\n            }\r\n            if (options.stickHoverStyle) {\r\n                this._spiderOptions.stickHoverStyle = options.stickHoverStyle;\r\n            }\r\n            if (options.stickStyle) {\r\n                this._spiderOptions.stickStyle = options.stickStyle;\r\n            }\r\n            if (options.markerSelected) {\r\n                this._spiderOptions.markerSelected = options.markerSelected;\r\n            }\r\n            if (options.markerUnSelected) {\r\n                this._spiderOptions.markerUnSelected = options.markerUnSelected;\r\n            }\r\n            if (typeof options.visible === 'boolean') {\r\n                this._spiderOptions.visible = options.visible;\r\n            }\r\n            this.SetOptions(<IClusterOptions>options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expands a cluster into it's open spider layout.\r\n     *\r\n     * @param cluster The cluster to show in it's open spider layout..\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private ShowSpiderCluster(cluster: Microsoft.Maps.ClusterPushpin): void {\r\n        this.HideSpiderCluster();\r\n        this._currentCluster = cluster;\r\n\r\n        if (cluster && cluster.containedPushpins) {\r\n            // Create spider data.\r\n            const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n            const pins: Array<Microsoft.Maps.Pushpin> = cluster.containedPushpins;\r\n            const center: Microsoft.Maps.Location = cluster.getLocation();\r\n            const centerPoint: Microsoft.Maps.Point =\r\n                <Microsoft.Maps.Point>m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control);\r\n            let stick: Microsoft.Maps.Polyline;\r\n            let angle = 0;\r\n            const makeSpiral: boolean = pins.length > this._spiderOptions.circleSpiralSwitchover;\r\n            let legPixelLength: number;\r\n            let stepAngle: number;\r\n            let stepLength: number;\r\n\r\n            if (makeSpiral) {\r\n                legPixelLength = this._spiderOptions.minCircleLength / Math.PI;\r\n                stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;\r\n            }\r\n            else {\r\n                stepAngle = 2 * Math.PI / pins.length;\r\n                legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;\r\n                if (legPixelLength < this._spiderOptions.minCircleLength) { legPixelLength = this._spiderOptions.minCircleLength; }\r\n            }\r\n\r\n            for (let i = 0, len = pins.length; i < len; i++) {\r\n                // Calculate spider pin location.\r\n                if (!makeSpiral) {\r\n                    angle = stepAngle * i;\r\n                }\r\n                else {\r\n                    angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;\r\n                    legPixelLength += stepLength / angle;\r\n                }\r\n                const point: Microsoft.Maps.Point =\r\n                    new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle),\r\n                        centerPoint.y + legPixelLength * Math.sin(angle));\r\n                const loc: Microsoft.Maps.Location =\r\n                    <Microsoft.Maps.Location>m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control);\r\n\r\n                // Create stick to pin.\r\n                stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);\r\n                this._spiderLayer.add(stick);\r\n\r\n                // Create pin in spiral that contains same metadata as parent pin.\r\n                const pin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc);\r\n                pin.metadata = pins[i].metadata || {};\r\n                pin.metadata.isClusterMarker = true;\r\n                pin.setOptions(this.GetBasicPushpinOptions(pins[i]));\r\n                this._spiderLayer.add(pin);\r\n\r\n                const spiderMarker: BingSpiderClusterMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);\r\n                spiderMarker.Stick = stick;\r\n                spiderMarker.ParentMarker = <BingMarker>this.GetMarkerFromBingMarker(pins[i]);\r\n                this._spiderMarkers.push(spiderMarker);\r\n                this._spiderMarkerLookup.set(pin, spiderMarker);\r\n\r\n            }\r\n            this._mapclicks = 0;\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoWindow} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof BingInfoWindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._infoBox && this._infoBox.getOptions().visible === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets native primitve underlying the model.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Infobox {\r\n        return this._infoBox;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of BingInfoWindow.\r\n     * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model\r\n     * @memberof BingInfoWindow\r\n     */\r\n    constructor(private _infoBox: Microsoft.Maps.Infobox) {\r\n        this._isOpen = false;\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._infoBox, eventType, (e) => {\r\n            if (e.eventName === 'infoboxChanged') {\r\n                if (this._infoBox.getOptions().visible === true) { this._isOpen = true; }\r\n                else {\r\n                    if (this._infoBox.getOptions().visible === false && this._isOpen === true) {\r\n                        this._isOpen = false;\r\n                        fn(e);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                fn(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Close(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = false;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        const p: ILatLong = {\r\n            latitude: this._infoBox.getLocation().latitude,\r\n            longitude: this._infoBox.getLocation().longitude\r\n        };\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Open(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = true;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = BingConversions.TranslateInfoBoxOptions(options);\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(position);\r\n        this._infoBox.setLocation(l);\r\n    }\r\n}\r\n","import { ILabelOptions } from '../interfaces/ilabel-options';\r\n\r\n/**\r\n * Abstract base implementing a label to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class MapLabel {\r\n// export class MapLabel extends Microsoft.Maps.CustomOverlay {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _canvas: HTMLCanvasElement;\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapLabel\r\n     */\r\n    public abstract get DefaultLabelStyle(): ILabelOptions;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        this.Set('fontFamily', 'sans-serif');\r\n        this.Set('fontSize', 12);\r\n        this.Set('fontColor', '#ffffff');\r\n        this.Set('strokeWeight', 4);\r\n        this.Set('strokeColor', '#000000');\r\n        this.Set('align', 'center');\r\n        this.SetValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the label from the map. This method does not atually delete the label itself, so\r\n     * it can be readded to map later.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Delegate called when underlying properties change.\r\n     *\r\n     * @param prop - The property or properties that have changed.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Changed(prop: string | Array<string>): void {\r\n        let shouldRunDrawCanvas = false;\r\n        let shouldRunDraw = false;\r\n        if (!Array.isArray(prop)) { prop = [prop]; }\r\n        prop.forEach(p => {\r\n            switch (p) {\r\n                case 'fontFamily':\r\n                case 'fontSize':\r\n                case 'fontColor':\r\n                case 'strokeWeight':\r\n                case 'strokeColor':\r\n                case 'align':\r\n                case 'text':\r\n                    shouldRunDrawCanvas = true;\r\n                    break;\r\n                case 'maxZoom':\r\n                case 'minZoom':\r\n                case 'offset':\r\n                case 'hidden':\r\n                case 'position':\r\n                    shouldRunDraw = true;\r\n                    break;\r\n            }\r\n        });\r\n        if (shouldRunDrawCanvas) { this.DrawCanvas(); }\r\n        if (shouldRunDraw) { this.Draw(); }\r\n    }\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Get(key: string): any;\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @returns - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @abstract\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Set(key: string, val: any): void;\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract SetValues(options: { [key: string]: any }): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Get the visibility of the label. Visibility depends on Zoom settings.\r\n     * @returns - blank string if visible, 'hidden' if invisible.\r\n     * @protected\r\n     */\r\n    protected GetVisible() {\r\n        const minZoom: number = this.Get('minZoom');\r\n        const maxZoom: number = this.Get('maxZoom');\r\n        const hidden: boolean = this.Get('hidden');\r\n\r\n        if (hidden) {return 'hidden'; }\r\n        if (minZoom === undefined && maxZoom === undefined) { return ''; }\r\n        if (!this.GetMap()) { return ''; }\r\n\r\n        const mapZoom: number = this.GetMap().getZoom();\r\n        if (mapZoom < minZoom || mapZoom > maxZoom) { return 'hidden'; }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract Draw(): void;\r\n\r\n    /**\r\n     * Draws the label to the canvas 2d context.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected DrawCanvas () {\r\n        if (!this._canvas) { return; }\r\n\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.zIndex = this.Get('zIndex');\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        ctx.strokeStyle = this.Get('strokeColor');\r\n        ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');\r\n\r\n        const backgroundColor: string = this.Get('backgroundColor');\r\n        const strokeWeight: number = Number(this.Get('strokeWeight'));\r\n        const text: string = this.Get('text');\r\n        const textMeasure: TextMetrics = ctx.measureText(text);\r\n        const textWidth: number = textMeasure.width;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, 4, 4);\r\n        }\r\n        if (backgroundColor && backgroundColor !== '') {\r\n            ctx.fillStyle = backgroundColor;\r\n            ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);\r\n        }\r\n        ctx.fillStyle = this.Get('fontColor');\r\n        ctx.fillText(text, 4, 4);\r\n\r\n        style.marginLeft = this.GetMarginLeft(textWidth) + 'px';\r\n        style.marginTop = '-0.4em';\r\n        style.pointerEvents = 'none';\r\n            // Bring actual text top in line with desired latitude.\r\n            // Cheaper than calculating height of text.\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate margin-left for the canvas.\r\n     * @param textWidth  - The width of the text, in pixels.\r\n     * @returns - The margin-left, in pixels.\r\n     * @protected\r\n     * @method\r\n     * @memberof MapLabel\r\n     */\r\n    protected GetMarginLeft(textWidth: number): number {\r\n        switch (this.Get('align')) {\r\n            case 'left':    return 0;\r\n            case 'right':   return -textWidth;\r\n        }\r\n        return textWidth / -2;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     * @abstract\r\n     */\r\n    protected abstract OnAdd(): void;\r\n\r\n    /**\r\n     * Called when the label is removed from the map.\r\n     * @method\r\n     * @protected\r\n     * @memberof MapLabel\r\n     */\r\n    protected OnRemove() {\r\n        if (this._canvas && this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n    }\r\n}\r\n\r\n","export class Extender {\r\n\r\n    private _obj: any;\r\n    private _proto: any;\r\n\r\n    constructor(obj: any) {\r\n        this._obj = obj;\r\n        this._proto = obj.prototype;\r\n    }\r\n\r\n    Extend(newObj: any): Extender {\r\n\r\n        this.Set('prototype', newObj, this._obj);\r\n\r\n        for (const y in this._proto) {\r\n            if ((<any>this._proto)[y] != null) {\r\n                this.Set(y, (this._proto)[y], (<any>this._obj.prototype)[y]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    Set(property: string, newObj: any, obj?: any): Extender {\r\n        if (typeof newObj === 'undefined') {\r\n            return this;\r\n        }\r\n\r\n        if (typeof obj === 'undefined') {\r\n            obj = this._proto;\r\n        }\r\n\r\n        Object.defineProperty(obj, property, newObj);\r\n    }\r\n\r\n    Map(property: string, newProperty: string): Extender {\r\n        this.Set(property, this._proto[newProperty], this._obj.prototype);\r\n        return this;\r\n    }\r\n}","import { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\nimport { MapLabel } from '../map-label';\r\nimport { Extender } from '../extender';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class BingMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 2,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 2;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n        (<any>this)._options.beneathLabels = false;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this)[key];\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new Microsoft.Maps.Location(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this)[key] = val;\r\n            this.Changed(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        const p: Array<string> = new Array<string>();\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' && !options[key].hasOwnProperty('altitude') &&\r\n                    options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);\r\n                }\r\n                if (this.Get(key) !== options[key]) {\r\n                    (<any>this)[key] = options[key];\r\n                    p.push(key);\r\n                }\r\n            }\r\n        }\r\n        if (p.length > 0) { this.Changed(p); }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const visibility: string = this.GetVisible();\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (!this._canvas) { return; }\r\n        if (!m) { return; }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: Microsoft.Maps.Point = this.Get('offset');\r\n        const latLng: Microsoft.Maps.Location = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!offset) { offset = new Microsoft.Maps.Point(0, 0); }\r\n\r\n        const pos: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(\r\n            latLng,\r\n            Microsoft.Maps.PixelReference.control);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.id = `xMapLabel${id++}`;\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        (<any>this).setHtmlElement(this._canvas);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate callled when the label is loaded\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    private OnLoad() {\r\n        Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', () => {\r\n            this.Changed('position');\r\n        });\r\n        this.DrawCanvas();\r\n        this.Draw();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the CustomOverlay into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinMapLabelWithOverlayView() {\r\n    new Extender(BingMapLabel)\r\n    .Extend(new Microsoft.Maps.CustomOverlay())\r\n    .Map('onAdd', 'OnAdd')\r\n    .Map('onLoad', 'OnLoad')\r\n    .Map('onRemove', 'OnRemove');\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { Polygon } from '../polygon';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolygon extends Polygon implements Polygon {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _map: Microsoft.Maps.Map = null;\r\n    private _isEditable: boolean = false;\r\n    private _title: string = '';\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _label: BingMapLabel = null;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link Microsoft.Maps.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.\r\n     * @param _mapService Instance of the Map Service.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolygon\r\n     */\r\n    constructor(\r\n        private _polygon: Microsoft.Maps.Polygon,\r\n        protected _mapService: BingMapService,\r\n        protected _layer: Microsoft.Maps.Layer,\r\n    ) {\r\n        super();\r\n        this._map = this._mapService.MapInstance;\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof BingPolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polygon, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        } if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8?\r\n        ///     forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polygon.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = this._polygon.getRings();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.latitude, longitude: y.longitude }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        //      ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw (new Error('The bing maps implementation currently does not support draggable polygons.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const isChanged = this._isEditable !== editable;\r\n        this._isEditable = editable;\r\n        if (!isChanged) {\r\n            return;\r\n        }\r\n\r\n        if (this._isEditable) {\r\n            this._originalPath = this.GetPaths();\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.edit(this._polygon);\r\n            });\r\n        }\r\n        else {\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.finish((editedPolygon: Microsoft.Maps.Polygon) => {\r\n                    if (editedPolygon !== this._polygon || !this._editingCompleteEmitter) {\r\n                        return;\r\n                    }\r\n                    const newPath: Array<Array<ILatLong>> = this.GetPaths();\r\n                    const originalPath: Array<Array<ILatLong>> = this._originalPath;\r\n                    this.SetPaths(newPath);\r\n                        // this is necessary for the new path to persist it appears.\r\n                    this._editingCompleteEmitter({\r\n                        Click: null,\r\n                        Polygon: this,\r\n                        OriginalPath: originalPath,\r\n                        NewPath: newPath\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n\r\n        if (typeof options.editable !== 'undefined') {\r\n            this.SetEditable(options.editable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._originalPath = [path];\r\n        this._polygon.setLocations(p);\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths\r\n     * An Array of {@link ILatLong} (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setRings(new Array<Microsoft.Maps.Location>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                path.forEach(x => _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            this._polygon.setRings(p);\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setOptions(<Microsoft.Maps.IPolygonOptions>{ visible: visible });\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: BingConversions.TranslateLocation(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                this._label = new BingMapLabel(o);\r\n                this._label.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        this._tooltip.Set('position', e.location);\r\n                        if (!this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', false);\r\n                            this._tooltipVisible = true;\r\n                        }\r\n                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (m: Microsoft.Maps.IMouseEventArgs) => {\r\n                                if (this._tooltipVisible && m.location && m.primitive === this._polygon) {\r\n                                    this._tooltip.Set('position', m.location);\r\n                                }\r\n                            });\r\n                    });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        if (this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', true);\r\n                            this._tooltipVisible = false;\r\n                        }\r\n                        if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                    });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { Polyline } from '../polyline';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isEditable: boolean = true;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the Navitve Polyline underlying the model\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolyline\r\n     */\r\n    constructor(private _polyline: Microsoft.Maps.Polyline, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof BingPolyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup' ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polyline, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polyline.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw(new Error('The bing maps implementation currently does not support draggable polylines.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._isEditable = editable;\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._polyline.setLocations(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setOptions(<Microsoft.Maps.IPolylineOptions>{ visible: visible });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                        this._polyline, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    this._tooltip.Set('position', e.location);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible && e.location && e.primitive === this._polyline) {\r\n                        this._tooltip.Set('position', e.location);\r\n                    }\r\n                });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                            this._polyline, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener) ; }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding bing map\r\n * equivalents.\r\n */\r\nexport const BingMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'viewchangeend',\r\n    centerchanged :     'viewchangeend',\r\n    zoomchanged :       'viewchangeend',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'infoboxChanged'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { BingMapLabel } from './bing-label';\r\nimport { Extender } from '../extender';\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.\r\n *\r\n * @export\r\n */\r\nexport class BingCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEvent: Microsoft.Maps.IHandlerId;\r\n    private _viewChangeEndEvent: Microsoft.Maps.IHandlerId;\r\n    private _mapResizeEvent: Microsoft.Maps.IHandlerId;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the BingCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller. Note that this method returns null until OnLoad has been called.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new Microsoft.Maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        const label: MapLabel = new BingMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public OnLoad() {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        this._centerStart = <ILatLong>map.getCenter();\r\n\r\n        // Redraw the canvas.\r\n        this.Redraw(true);\r\n\r\n        // When the map moves, move the canvas accordingly.\r\n        this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', (e) => {\r\n            if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {\r\n                // Don't show the canvas if the map is in Streetside mode.\r\n                this._canvas.style.display = 'none';\r\n            }\r\n            else {\r\n                // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n                const zoomCurrent: number = map.getZoom();\r\n                const centerCurrent: Microsoft.Maps.Location = map.getCenter();\r\n\r\n                // Calculate map scale based on zoom level difference.\r\n                const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n                // Calculate the scaled dimensions of the canvas.\r\n                const newWidth: number = map.getWidth() * scale;\r\n                const newHeight: number = map.getHeight() * scale;\r\n\r\n                // Calculate offset of canvas based on zoom and center offsets.\r\n                const pixelPoints: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>map.tryLocationToPixel([\r\n                        BingConversions.TranslateLocation(this._centerStart),\r\n                        centerCurrent\r\n                    ], Microsoft.Maps.PixelReference.control);\r\n                const centerOffsetX: number = pixelPoints[1].x - pixelPoints[0].x;\r\n                const centerOffsetY: number = pixelPoints[1].y - pixelPoints[0].y;\r\n                const x: number = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;\r\n                const y: number = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;\r\n\r\n                // Update the canvas CSS position and dimensions.\r\n                this.UpdatePosition(x, y, newWidth, newHeight);\r\n            }\r\n        });\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        (<any>this).setHtmlElement(el);\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        this._canvas.width = map.getWidth();\r\n        this._canvas.height = map.getHeight();\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            this._centerStart = <ILatLong>map.getCenter();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n\r\n    new Extender(BingCanvasOverlay)\r\n    .Extend(new Microsoft.Maps.CustomOverlay())\r\n    .Map('onAdd', 'OnAdd')\r\n    .Map('onLoad', 'OnLoad')\r\n    .Map('onRemove', 'OnRemove');\r\n}\r\n","export let google: any;\r\n\r\nexport interface GoogleMap extends MVCObject {\r\n  data?: Data;\r\n  constructor(el: HTMLElement, opts?: MapOptions): void;\r\n  panTo(latLng: LatLng|LatLngLiteral): void;\r\n  setZoom(zoom: number): void;\r\n  getCenter(): LatLng;\r\n  setCenter(latLng: LatLng|LatLngLiteral): void;\r\n  getBounds(): LatLngBounds;\r\n  getZoom(): number;\r\n  getDiv(): HTMLDivElement;\r\n  getProjection(): any;\r\n  setOptions(options: MapOptions): void;\r\n  panToBounds(latLngBounds: LatLngBounds|LatLngBoundsLiteral): void;\r\n  fitBounds(bounds: LatLngBounds|LatLngBoundsLiteral): void;\r\n}\r\n\r\nexport interface LatLng {\r\n  constructor(lat: number, lng: number): void;\r\n  lat(): number;\r\n  lng(): number;\r\n}\r\n\r\nexport interface Marker extends MVCObject {\r\n  constructor(options?: MarkerOptions): void;\r\n  setMap(map: GoogleMap): void;\r\n  setPosition(latLng: LatLng|LatLngLiteral): void;\r\n  setTitle(title: string): void;\r\n  setLabel(label: string|MarkerLabel): void;\r\n  setPosition(latlng: LatLng|LatLngLiteral): void;\r\n  setDraggable(draggable: boolean): void;\r\n  setIcon(icon: string): void;\r\n  setOpacity(opacity: number): void;\r\n  setOptions(options: MarkerOptions): void;\r\n  setVisible(visible: boolean): void;\r\n  setZIndex(zIndex: number): void;\r\n  getLabel(): MarkerLabel;\r\n  getPosition(): LatLng;\r\n  getVisible(): boolean;\r\n}\r\n\r\nexport interface MarkerOptions {\r\n  position: LatLng|LatLngLiteral;\r\n  title?: string;\r\n  map?: GoogleMap;\r\n  label?: string|MarkerLabel;\r\n  draggable?: boolean;\r\n  clickable?: boolean;\r\n  icon?: string;\r\n  opacity?: number;\r\n  visible?: boolean;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface MarkerLabel {\r\n  color: string;\r\n  fontFamily: string;\r\n  fontSize: string;\r\n  fontWeight: string;\r\n  text: string;\r\n}\r\n\r\nexport interface ClusterStyle {\r\n  url?: string;\r\n  height?: number;\r\n  width?: number;\r\n  anchor?: Array<number>;\r\n  textColor?: string;\r\n  textSize?: number;\r\n  backgroundPosition?: string;\r\n}\r\n\r\nexport interface MarkerClusterer {\r\n  isZoomOnClick(): boolean;\r\n  isAverageCenter(): boolean;\r\n  getMarkers(): Array<Marker>;\r\n  getTotalMarkers(): number;\r\n  setMaxZoom(maxZoom: number): void;\r\n  getMaxZoom(): number;\r\n  addMarkers(markers: Array<Marker>, opt_nodraw?: boolean): void;\r\n  addMarker(marker: Marker, opt_nodraw?: boolean): void;\r\n  removeMarkers(markers: Array<Marker>, opt_nodraw?: boolean): void;\r\n  removeMarker(marker: Marker, opt_nodraw?: boolean): void;\r\n  getTotalClusters(): number;\r\n  getMap(): GoogleMap;\r\n  setMap(map: GoogleMap): void;\r\n  getGridSize(): number;\r\n  setGridSize(gridSize: number): void;\r\n  getMinClusterSize(): number;\r\n  setMinClusterSize(minClusterSize: number): void;\r\n  clearMarkers(): void;\r\n  setStyles(styles: Array<ClusterStyle>): void;\r\n  getStyles(): Array<ClusterStyle>;\r\n  setCalculator(callback: (markers: Array<Marker>, numStyles: number) => { text: string, index: number}): void;\r\n  getCalculator(): (markers: Array<Marker>, numStyles: number) => { text: string, index: number};\r\n  resetViewport(hide?: boolean): void;\r\n  redraw(): void;\r\n}\r\n\r\nexport interface Circle extends MVCObject {\r\n  getBounds(): LatLngBounds;\r\n  getCenter(): LatLng;\r\n  getDraggable(): boolean;\r\n  getEditable(): boolean;\r\n  getMap(): GoogleMap;\r\n  getRadius(): number;\r\n  getVisible(): boolean;\r\n  setCenter(center: LatLng|LatLngLiteral): void;\r\n  setDraggable(draggable: boolean): void;\r\n  setEditable(editable: boolean): void;\r\n  setMap(map: GoogleMap): void;\r\n  setOptions(options: CircleOptions): void;\r\n  setRadius(radius: number): void;\r\n  setVisible(visible: boolean): void;\r\n}\r\n\r\nexport interface CircleOptions {\r\n  center?: LatLng|LatLngLiteral;\r\n  clickable?: boolean;\r\n  draggable?: boolean;\r\n  editable?: boolean;\r\n  fillColor?: string;\r\n  fillOpacity?: number;\r\n  map?: GoogleMap;\r\n  radius?: number;\r\n  strokeColor?: string;\r\n  strokeOpacity?: number;\r\n  strokePosition?: 'CENTER'|'INSIDE'|'OUTSIDE';\r\n  strokeWeight?: number;\r\n  visible?: boolean;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface LatLngBounds {\r\n  contains(latLng: LatLng): boolean;\r\n  equals(other: LatLngBounds|LatLngBoundsLiteral): boolean;\r\n  extend(point: LatLng): void;\r\n  getCenter(): LatLng;\r\n  getNorthEast(): LatLng;\r\n  getSouthWest(): LatLng;\r\n  intersects(other: LatLngBounds|LatLngBoundsLiteral): boolean;\r\n  isEmpty(): boolean;\r\n  toJSON(): LatLngBoundsLiteral;\r\n  toSpan(): LatLng;\r\n  toString(): string;\r\n  toUrlValue(precision?: number): string;\r\n  union(other: LatLngBounds|LatLngBoundsLiteral): LatLngBounds;\r\n}\r\n\r\nexport interface LatLngBoundsLiteral {\r\n  east: number;\r\n  north: number;\r\n  south: number;\r\n  west: number;\r\n}\r\n\r\nexport interface LatLngLiteral {\r\n  lat: number;\r\n  lng: number;\r\n}\r\n\r\nexport interface MouseEvent { latLng: LatLng; }\r\n\r\nexport interface MapOptions {\r\n  center?: LatLng|LatLngLiteral;\r\n  zoom?: number;\r\n  minZoom?: number;\r\n  maxZoom?: number;\r\n  disableDoubleClickZoom?: boolean;\r\n  disableDefaultUI?: boolean;\r\n  scrollwheel?: boolean;\r\n  backgroundColor?: string;\r\n  draggable?: boolean;\r\n  draggableCursor?: string;\r\n  draggingCursor?: string;\r\n  keyboardShortcuts?: boolean;\r\n  styles?: MapTypeStyle[];\r\n  zoomControl?: boolean;\r\n  zoomControlOptions?: ZoomControlOptions;\r\n  streetViewControl?: boolean;\r\n  streetViewControlOptions?: StreetViewControlOptions;\r\n  scaleControl?: boolean;\r\n  scaleControlOptions?: ScaleControlOptions;\r\n  mapTypeControl?: boolean;\r\n  mapTypeControlOptions?: MapTypeControlOptions;\r\n  panControl?: boolean;\r\n  panControlOptions?: PanControlOptions;\r\n  rotateControl?: boolean;\r\n  rotateControlOptions?: RotateControlOptions;\r\n  fullscreenControl?: boolean;\r\n  fullscreenControlOptions?: FullscreenControlOptions;\r\n  mapTypeId?: string|MapTypeId;\r\n  clickableIcons?: boolean;\r\n  gestureHandling?: 'cooperative'|'greedy'|'none'|'auto';\r\n}\r\n\r\nexport interface MapTypeStyle {\r\n  elementType?: 'all'|'geometry'|'geometry.fill'|'geometry.stroke'|'labels'|'labels.icon'|\r\n      'labels.text'|'labels.text.fill'|'labels.text.stroke';\r\n  featureType?: 'administrative'|'administrative.country'|'administrative.land_parcel'|\r\n      'administrative.locality'|'administrative.neighborhood'|'administrative.province'|'all'|\r\n      'landscape'|'landscape.man_made'|'landscape.natural'|'landscape.natural.landcover'|\r\n      'landscape.natural.terrain'|'poi'|'poi.attraction'|'poi.business'|'poi.government'|\r\n      'poi.medical'|'poi.park'|'poi.place_of_worship'|'poi.school'|'poi.sports_complex'|'road'|\r\n      'road.arterial'|'road.highway'|'road.highway.controlled_access'|'road.local'|'transit'|\r\n      'transit.line'|'transit.station'|'transit.station.airport'|'transit.station.bus'|\r\n      'transit.station.rail'|'water';\r\n  stylers: MapTypeStyler[];\r\n}\r\n\r\n/**\r\n *  If more than one key is specified in a single MapTypeStyler, all but one will be ignored.\r\n */\r\nexport interface MapTypeStyler {\r\n  color?: string;\r\n  gamma?: number;\r\n  hue?: string;\r\n  invert_lightness?: boolean;\r\n  lightness?: number;\r\n  saturation?: number;\r\n  visibility?: string;\r\n  weight?: number;\r\n}\r\n\r\nexport interface InfoWindow extends MVCObject {\r\n  constructor(opts?: InfoWindowOptions): void;\r\n  close(): void;\r\n  getContent(): string|Node;\r\n  getPosition(): LatLng;\r\n  getZIndex(): number;\r\n  open(map?: GoogleMap, anchor?: MVCObject): void;\r\n  setContent(content: string|Node): void;\r\n  setOptions(options: InfoWindowOptions): void;\r\n  setPosition(position: LatLng|LatLngLiteral): void;\r\n  setZIndex(zIndex: number): void;\r\n}\r\n\r\nexport interface MVCObject { addListener(eventName: string, handler: Function): MapsEventListener; }\r\n\r\nexport interface MapsEventListener { remove(): void; }\r\n\r\nexport interface Size {\r\n  height: number;\r\n  width: number;\r\n  constructor(width: number, height: number, widthUnit?: string, heightUnit?: string): void;\r\n  equals(other: Size): boolean;\r\n  toString(): string;\r\n}\r\n\r\nexport interface InfoWindowOptions {\r\n  content?: string|Node;\r\n  disableAutoPan?: boolean;\r\n  maxWidth?: number;\r\n  pixelOffset?: Size;\r\n  position?: LatLng|LatLngLiteral;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n  equals(other: Point): boolean;\r\n  toString(): string;\r\n}\r\n\r\nexport interface GoogleSymbol {\r\n  anchor?: Point;\r\n  fillColor?: string;\r\n  fillOpacity?: string;\r\n  labelOrigin?: Point;\r\n  path?: string;\r\n  rotation?: number;\r\n  scale?: number;\r\n  strokeColor?: string;\r\n  strokeOpacity?: number;\r\n  strokeWeight?: number;\r\n}\r\n\r\nexport interface IconSequence {\r\n  fixedRotation?: boolean;\r\n  icon?: GoogleSymbol;\r\n  offset?: string;\r\n  repeat?: string;\r\n}\r\n\r\nexport interface PolylineOptions {\r\n  clickable?: boolean;\r\n  draggable?: boolean;\r\n  editable?: boolean;\r\n  geodesic?: boolean;\r\n  icon?: Array<IconSequence>;\r\n  map?: GoogleMap;\r\n  path?: Array<LatLng>|Array<LatLng|LatLngLiteral>;\r\n  strokeColor?: string;\r\n  strokeOpacity?: number;\r\n  strokeWeight?: number;\r\n  visible?: boolean;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface Polyline extends MVCObject {\r\n  getDraggable(): boolean;\r\n  getEditable(): boolean;\r\n  getMap(): GoogleMap;\r\n  getPath(): Array<LatLng>;\r\n  getVisible(): boolean;\r\n  setDraggable(draggable: boolean): void;\r\n  setEditable(editable: boolean): void;\r\n  setMap(map: GoogleMap): void;\r\n  setOptions(options: PolylineOptions): void;\r\n  setPath(path: Array<LatLng|LatLngLiteral>): void;\r\n  setVisible(visible: boolean): void;\r\n}\r\n\r\n/**\r\n * PolyMouseEvent gets emitted when the user triggers mouse events on a polyline.\r\n */\r\nexport interface PolyMouseEvent extends MouseEvent {\r\n  edge: number;\r\n  path: number;\r\n  vertex: number;\r\n}\r\n\r\nexport interface PolygonOptions {\r\n  clickable?: boolean;\r\n  draggable?: boolean;\r\n  editable?: boolean;\r\n  fillColor?: string;\r\n  fillOpacity?: number;\r\n  geodesic?: boolean;\r\n  icon?: Array<IconSequence>;\r\n  map?: GoogleMap;\r\n  paths?: Array<LatLng|LatLngLiteral>|Array<Array<LatLng|LatLngLiteral>>;\r\n  strokeColor?: string;\r\n  strokeOpacity?: number;\r\n  strokeWeight?: number;\r\n  visible?: boolean;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface Polygon extends MVCObject {\r\n  zIndex: number;\r\n  getDraggable(): boolean;\r\n  getEditable(): boolean;\r\n  getMap(): GoogleMap;\r\n  getPath(): Array<LatLng>;\r\n  getPaths(): Array<Array<LatLng>>;\r\n  getVisible(): boolean;\r\n  setDraggable(draggable: boolean): void;\r\n  setEditable(editable: boolean): void;\r\n  setMap(map: GoogleMap): void;\r\n  setPath(path: Array<LatLng>|Array<LatLng|LatLngLiteral>): void;\r\n  setOptions(options: PolygonOptions): void;\r\n  setPaths(paths: Array<Array<LatLng|LatLngLiteral>>|Array<LatLng|LatLngLiteral>): void;\r\n  setVisible(visible: boolean): void;\r\n}\r\n\r\nexport interface KmlLayer extends MVCObject {\r\n  getDefaultViewport(): LatLngBounds;\r\n  getMap(): GoogleMap;\r\n  getMetadata(): KmlLayerMetadata;\r\n  getStatus(): KmlLayerStatus;\r\n  getUrl(): string;\r\n  getZIndex(): number;\r\n  setMap(map: GoogleMap): void;\r\n  setOptions(options: KmlLayerOptions): void;\r\n  setUrl(url: string): void;\r\n  setZIndex(zIndex: number): void;\r\n}\r\n\r\n/**\r\n * See: https://developers.google.com/maps/documentation/javascript/reference?hl=de#KmlLayerStatus\r\n */\r\nexport type KmlLayerStatus = 'DOCUMENT_NOT_FOUND' |\r\n    'DOCUMENT_TOO_LARGE' | 'FETCH_ERROR' | 'INVALID_DOCUMENT' | 'INVALID_REQUEST' |\r\n    'LIMITS_EXCEEDED' | 'OK' | 'TIMED_OUT' | 'UNKNOWN';\r\n\r\n/**\r\n * See: https://developers.google.com/maps/documentation/javascript/reference?hl=de#KmlLayerMetadata\r\n */\r\nexport interface KmlLayerMetadata {\r\n  author: KmlAuthor;\r\n  description: string;\r\n  hasScreenOverlays: boolean;\r\n  name: string;\r\n  snippet: string;\r\n}\r\n\r\nexport interface KmlAuthor {\r\n  email: string;\r\n  name: string;\r\n  uri: string;\r\n}\r\n\r\nexport interface KmlLayerOptions {\r\n  clickable?: boolean;\r\n  map?: GoogleMap;\r\n  preserveViewport?: boolean;\r\n  screenOverlays?: boolean;\r\n  suppressInfoWindows?: boolean;\r\n  url?: string;\r\n  zIndex?: number;\r\n}\r\n\r\nexport interface KmlFeatureData {\r\n  author: KmlAuthor;\r\n  description: string;\r\n  id: string;\r\n  infoWindowHtml: string;\r\n  name: string;\r\n  snippet: string;\r\n}\r\n\r\nexport interface KmlMouseEvent extends MouseEvent {\r\n  featureData: KmlFeatureData;\r\n  pixelOffset: Size;\r\n}\r\n\r\nexport interface Data extends MVCObject {\r\n  features: Feature[];\r\n  constructor(options?: DataOptions): void;\r\n  addGeoJson(geoJson: Object, options?: GeoJsonOptions): Feature[];\r\n  remove(feature: Feature): void;\r\n  setControlPosition(controlPosition: ControlPosition): void;\r\n  setControls(controls: string[]): void;\r\n  setDrawingMode(drawingMode: string): void;\r\n  setMap(map: GoogleMap): void;\r\n  /* tslint:disable */\r\n  /*\r\n  * Tslint configuration check-parameters will prompt errors for these lines of code.\r\n  * https://palantir.github.io/tslint/rules/no-unused-variable/\r\n  */\r\n  setStyle(style: () => void): void;\r\n  forEach(callback: (feature: Feature) => void): void;\r\n  /* tslint:enable */\r\n}\r\n\r\nexport interface Feature extends MVCObject {\r\n  id?: number|string|undefined;\r\n  geometry: Geometry;\r\n  properties: any;\r\n}\r\n\r\nexport interface DataOptions {\r\n  controlPosition?: ControlPosition;\r\n  controls?: string[];\r\n  drawingMode?: string;\r\n  featureFactory?: (geometry: Geometry) => Feature;\r\n  map?: GoogleMap;\r\n  style?: () => void;\r\n}\r\n\r\nexport interface DataMouseEvent extends MouseEvent {\r\n  feature: Feature;\r\n}\r\n\r\nexport interface GeoJsonOptions {\r\n  idPropertyName: string;\r\n}\r\n\r\nexport interface Geometry {\r\n  type: string;\r\n}\r\n\r\n/**\r\n * Identifiers used to specify the placement of controls on the map. Controls are\r\n * positioned relative to other controls in the same layout position. Controls that\r\n * are added first are positioned closer to the edge of the map.\r\n */\r\nexport enum ControlPosition {\r\n  BOTTOM_CENTER,\r\n  BOTTOM_LEFT,\r\n  BOTTOM_RIGHT,\r\n  LEFT_BOTTOM,\r\n  LEFT_CENTER,\r\n  LEFT_TOP,\r\n  RIGHT_BOTTOM,\r\n  RIGHT_CENTER,\r\n  RIGHT_TOP,\r\n  TOP_CENTER,\r\n  TOP_LEFT,\r\n  TOP_RIGHT\r\n}\r\n\r\nexport enum MapTypeId {\r\n  /** This map type displays a transparent layer of major streets on satellite images. */\r\n  hybrid,\r\n  /** This map type displays a normal street map. */\r\n  roadmap,\r\n  /** This map type displays satellite images. */\r\n  satellite,\r\n  /** This map type displays maps with physical features such as terrain and vegetation. */\r\n  terrain\r\n}\r\n\r\n/***** Controls *****/\r\n/** Options for the rendering of the map type control. */\r\nexport interface MapTypeControlOptions {\r\n  /** IDs of map types to show in the control. */\r\n  mapTypeIds?: (MapTypeId|string)[];\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map.\r\n   * The default position is TOP_RIGHT.\r\n   */\r\n  position?: ControlPosition;\r\n  /** Style id. Used to select what style of map type control to display. */\r\n  style?: MapTypeControlStyle;\r\n}\r\n\r\nexport enum MapTypeControlStyle {\r\n  DEFAULT,\r\n  DROPDOWN_MENU,\r\n  HORIZONTAL_BAR\r\n}\r\n\r\nexport interface OverviewMapControlOptions {\r\n  opened?: boolean;\r\n}\r\n\r\n/** Options for the rendering of the pan control. */\r\nexport interface PanControlOptions {\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map.\r\n   * The default position is TOP_LEFT.\r\n   */\r\n  position?: ControlPosition;\r\n}\r\n\r\n/** Options for the rendering of the rotate control. */\r\nexport interface RotateControlOptions {\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map.\r\n   * The default position is TOP_LEFT.\r\n   */\r\n  position?: ControlPosition;\r\n}\r\n\r\n/** Options for the rendering of the scale control. */\r\nexport interface ScaleControlOptions {\r\n  /** Style id. Used to select what style of scale control to display. */\r\n  style?: ScaleControlStyle;\r\n}\r\n\r\nexport enum ScaleControlStyle {\r\n  DEFAULT\r\n}\r\n\r\n/** Options for the rendering of the Street View pegman control on the map. */\r\nexport interface StreetViewControlOptions {\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map. The\r\n   * default position is embedded within the navigation (zoom and pan) controls.\r\n   * If this position is empty or the same as that specified in the\r\n   * zoomControlOptions or panControlOptions, the Street View control will be\r\n   * displayed as part of the navigation controls. Otherwise, it will be displayed\r\n   * separately.\r\n   */\r\n  position?: ControlPosition;\r\n}\r\n\r\n/** Options for the rendering of the zoom control. */\r\nexport interface ZoomControlOptions {\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map.\r\n   * The default position is TOP_LEFT.\r\n   */\r\n  position?: ControlPosition;\r\n  style?: ZoomControlStyle;\r\n}\r\n\r\nexport enum ZoomControlStyle {\r\n  DEFAULT,\r\n  LARGE,\r\n  SMALL\r\n}\r\n\r\n/** Options for the rendering of the fullscreen control. */\r\nexport interface FullscreenControlOptions {\r\n  /**\r\n   * Position id. Used to specify the position of the control on the map.\r\n   * The default position is RIGHT_TOP.\r\n   */\r\n  position?: ControlPosition;\r\n}\r\n\r\nexport declare class OverlayView {\r\n    public set(key: string, value: any): void;\r\n    public get(key: string): any;\r\n    public setValues(options: any): void;\r\n    public getPanes(): any;\r\n    public getProjection(): any;\r\n    public getMap(): GoogleMap;\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport * as GoogleMapTypes from './google-map-types';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\n\r\ndeclare var google: any;\r\n\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Google Maps specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class GoogleConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'center',\r\n        'clickableIcons',\r\n        'customMapStyleGoogle',\r\n        'disableDefaultUI',\r\n        'disableDoubleClickZoom',\r\n        'draggable',\r\n        'draggableCursor',\r\n        'draggingCursor',\r\n        'disableZooming',\r\n        'fullscreenControl',\r\n        'fullscreenControlOptions',\r\n        'gestureHandling',\r\n        'heading',\r\n        'keyboardShortcuts',\r\n        'mapTypeControl',\r\n        'mapTypeControlOptions',\r\n        'mapTypeId',\r\n        'maxZoom',\r\n        'minZoom',\r\n        'noClear',\r\n        'panControl',\r\n        'panControlOptions',\r\n        'rotateControl',\r\n        'rotateControlOptions',\r\n        'scaleControl',\r\n        'scaleControlOptions',\r\n        'scrollwheel',\r\n        'showMapTypeSelector',\r\n        'streetView',\r\n        'streetViewControl',\r\n        'streetViewControlOptions',\r\n        'styles',\r\n        'tilt',\r\n        'zoom',\r\n        'zoomControl',\r\n        'zoomControlOptions'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'position',\r\n        'title',\r\n        'text',\r\n        'label',\r\n        'draggable',\r\n        'icon',\r\n        'width',\r\n        'height',\r\n        'iconInfo',\r\n        'metadata',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'geodesic',\r\n        'paths',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'geodesic',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.\r\n     *\r\n     * @param bounds - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateBounds(bounds: IBox): GoogleMapTypes.LatLngBoundsLiteral {\r\n        const b: GoogleMapTypes.LatLngBoundsLiteral = {\r\n            east: bounds.maxLongitude,\r\n            north: bounds.maxLatitude,\r\n            south: bounds.minLatitude,\r\n            west: bounds.minLongitude,\r\n        };\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateInfoWindowOptions(options: IInfoWindowOptions): GoogleMapTypes.InfoWindowOptions {\r\n        const o: GoogleMapTypes.InfoWindowOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'htmlContent') {\r\n                    o.content = (<any>options)[k];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        if (o.content == null || o.content === '') {\r\n            if (options.title !== '' && options.description !== '') {\r\n                o.content = `${options.title}: ${options.description}`;\r\n            }\r\n            else if (options.description !== '') { o.content = options.description; }\r\n            else { o.content = options.title; }\r\n        }\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): GoogleMapTypes.LatLngLiteral {\r\n        const l: GoogleMapTypes.LatLngLiteral = { lat: latlong.latitude, lng: latlong.longitude };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLng(latlng: GoogleMapTypes.LatLngLiteral): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat, longitude: latlng.lng };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObject(latlong: ILatLong): GoogleMapTypes.LatLng {\r\n        const l: GoogleMapTypes.LatLng = new google.maps.LatLng(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLng object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLngObject(latlng: GoogleMapTypes.LatLng): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat(), longitude: latlng.lng() };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlongArray - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObjectArray(latlongArray: Array<ILatLong>): Array<GoogleMapTypes.LatLng> {\r\n        // use for loop for performance in case we deal with large numbers of points and paths...\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        for (let i = 0; i < latlongArray.length; i++) {\r\n            p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Maps a MapTypeId object to a Google maptype string.\r\n     *\r\n     * @param mapTypeId - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMapTypeId(mapTypeId: MapTypeId): string {\r\n        switch (mapTypeId) {\r\n            case MapTypeId.road: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.roadmap];\r\n            case MapTypeId.grayscale: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            case MapTypeId.hybrid: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.hybrid];\r\n            case MapTypeId.ordnanceSurvey: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            default: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.satellite];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Promise that when resolved contains the mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): GoogleMapTypes.MarkerOptions {\r\n        const o: GoogleMapTypes.MarkerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'position') {\r\n                    const latlng = GoogleConversions.TranslateLocationObject(options[k]);\r\n                    o.position = latlng;\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): GoogleMapTypes.MapOptions {\r\n        const o: GoogleMapTypes.MapOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = GoogleConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);\r\n                }\r\n                else if (k === 'disableZooming') {\r\n                    o.gestureHandling = 'none';\r\n                    o.zoomControl =  false;\r\n                }\r\n                else if (k === 'showMapTypeSelector') {\r\n                    o.mapTypeControl = false;\r\n                }\r\n                else if (k === 'customMapStyleGoogle') {\r\n                    o.styles = <GoogleMapTypes.MapTypeStyle[]><any> options.customMapStyleGoogle\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<GoogleMapTypes.LatLng>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<GoogleMapTypes.LatLng>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // use for loop for performance in case we deal with large numbers of points and paths...\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            p.push(GoogleConversions.TranslateLocationObjectArray(<Array<ILatLong>>paths));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): GoogleMapTypes.PolygonOptions {\r\n        const o: GoogleMapTypes.PolygonOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'paths') {\r\n                    if (!Array.isArray(options.paths)) { return; }\r\n                    if (options.paths.length === 0) {\r\n                        o.paths = new Array<GoogleMapTypes.LatLng>();\r\n                    }\r\n                    else if (Array.isArray(options.paths[0])) {\r\n                        o.paths = new Array<Array<GoogleMapTypes.LatLngLiteral>>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<Array<ILatLong>>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                            for (let j = 0; j < p1[i].length; j++) {\r\n                                o.paths[i][j] = {lat: p1[i][j].latitude, lng: p1[i][j].longitude};\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        o.paths = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<ILatLong>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = {lat: p1[i].latitude, lng: p1[i].longitude};\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): GoogleMapTypes.PolylineOptions {\r\n        const o: GoogleMapTypes.PolylineOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                o[k] = (<any>options)[k];\r\n            });\r\n        return o;\r\n    }\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { GoogleMapService} from '../../services/google/google-map.service';\r\nimport { InfoWindow } from '../info-window';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a {@link InfoWindow}} model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoWGoogleInfoWindowindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._isOpen === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying native object.\r\n     *\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.InfoWindow {\r\n        return this._infoWindow;\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoWindow.\r\n     * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.\r\n     * @param _mapService - An instance of the {@link GoogleMapService}.\r\n     * @memberof GoogleInfoWindow\r\n     */\r\n    constructor(private _infoWindow: GoogleMapTypes.InfoWindow, private _mapService: GoogleMapService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n   /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._infoWindow.addListener(eventType, (e: any) => {\r\n            if (eventType === 'closeclick') { this._isOpen = false; }\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Closes the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Close() {\r\n        this._isOpen = false;\r\n        this._infoWindow.close();\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window\r\n     *\r\n     * @returns - The geo coordinates of the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());\r\n    }\r\n\r\n    /**\r\n     * Opens the info window\r\n     *\r\n     * @param [anchor] - Optional Anchor.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Open(anchor?: any) {\r\n        this._mapService.MapPromise.then(m => {\r\n            this._isOpen = true;\r\n            this._infoWindow.open(m, anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param options - The options to set. This object will be merged with the existing options.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n        this._infoWindow.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param position - Geo coordinates at which to anchor the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: GoogleMapTypes.LatLngLiteral = GoogleConversions.TranslateLocation(position);\r\n        this._infoWindow.setPosition(l);\r\n    }\r\n}\r\n","import { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Marker } from '../marker';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Google Maps map architecture.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarker implements Marker {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Marker { return this._marker; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: GoogleMapTypes.LatLng = this._marker.getPosition();\r\n        return {\r\n            latitude: l.lat(),\r\n            longitude: l.lng()\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarker.\r\n     * @param _marker\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    constructor(private _marker: GoogleMapTypes.Marker) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._marker.addListener(eventType, fn);\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        this._marker.setMap(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._marker.getLabel().text;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._marker.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetAnchor(anchor: any): void {\r\n        // not implemented\r\n        // TODO: we need to switch the model to complex icons for google to\r\n        // support anchors, sizes and origins.\r\n        // https://developers.google.com/maps/documentation/javascript/markers\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._marker.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        this._marker.setIcon(icon);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        this._marker.setLabel(label);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n        this._marker.setPosition(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        this._marker.setTitle(title);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n        this._marker.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._marker.setVisible(visible);\r\n    }\r\n\r\n}\r\n","import * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { MapLabel } from '../map-label';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\nimport { Extender } from '../extender';\r\n\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof GoogleMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 3,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 3;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this).get(key);\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new google.maps.LatLng(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this).set(key, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' &&  options[key].hasOwnProperty('latitude') &&  options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new google.maps.LatLng( options[key].latitude,  options[key].longitude);\r\n                }\r\n                if (this.Get(key) === options[key]) { delete options[key]; }\r\n            }\r\n        }\r\n        (<any>this).setValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const projection = (<any>this).getProjection();\r\n        const visibility: string = this.GetVisible();\r\n        if (!projection) {\r\n            // The map projection is not ready yet so do nothing\r\n            return;\r\n        }\r\n        if (!this._canvas) {\r\n            // onAdd has not been called yet.\r\n            return;\r\n        }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: GoogleMapTypes.Point = this.Get('offset');\r\n        let latLng: GoogleMapTypes.LatLng|GoogleMapTypes.LatLngLiteral = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!(latLng instanceof google.maps.LatLng)) { latLng = new google.maps.LatLng(latLng.lat, latLng.lng); }\r\n        if (!offset) { offset = new google.maps.Point(0, 0); }\r\n\r\n        const pos = projection.fromLatLngToDivPixel(latLng);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        this.DrawCanvas();\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            panes.overlayLayer.appendChild(this._canvas);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\n\r\n\r\nexport function MixinMapLabelWithOverlayView() {\r\n\r\n    new Extender(GoogleMapLabel)\r\n        .Extend(new google.maps.OverlayView)\r\n        .Map('changed', 'Changed')\r\n        .Map('onAdd', 'OnAdd')\r\n        .Map('draw', 'Draw')\r\n        .Map('onRemove', 'OnRemove');\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { Polygon } from '../polygon';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolygon extends Polygon implements Polygon {\r\n\r\n    private _title: string = '';\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _label: GoogleMapLabel = null;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void = null;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GoolePolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link GoogleMapTypes.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    constructor(private _polygon: GoogleMapTypes.Polygon) {\r\n        super();\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof GooglePolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polygon.addListener(eventType, fn);\r\n        }\r\n        if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public Delete(): void {\r\n        this._polygon.setMap(null);\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polygon.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polygon.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polygon.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = this._polygon.getPaths();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.lat(), longitude: y.lng() }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polygon.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const previous = this._polygon.getEditable();\r\n        this._polygon.setEditable(editable);\r\n        if (previous && !editable && this._editingCompleteEmitter) {\r\n            this._editingCompleteEmitter({\r\n                Click: null,\r\n                Polygon: this,\r\n                OriginalPath: this._originalPath,\r\n                NewPath: this.GetPaths()\r\n            });\r\n            this._originalPath = this.GetPaths();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n\r\n        if (typeof o.editable !== 'undefined') {\r\n            this.SetEditable(o.editable);\r\n            delete o.editable;\r\n        }\r\n\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polygon.setPath(p);\r\n        this._originalPath = [path];\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setPaths(new Array<GoogleMapTypes.LatLng>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n                path.forEach(x => _p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._polygon.setPaths(p);\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        } else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setVisible(visible);\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: GoogleConversions.TranslateLocationObject(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;\r\n                this._label = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport { Polyline } from '../polyline';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link GoogleMApTypes.Polyline}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n     /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.\r\n     *\r\n     * @memberof GooglePolyline\r\n     */\r\n    constructor(private _polyline: GoogleMapTypes.Polyline) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polyline.addListener(eventType, fn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public Delete(): void {\r\n        this._polyline.setMap(null);\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polyline.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polyline.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polyline.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polyline.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._polyline.setEditable(editable);\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polyline.setPath(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setVisible(visible);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n    /**\r\n     * Configures the tooltip for the polyline\r\n     * @memberof GooglePolyline\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding google map\r\n * equivalents.\r\n */\r\nexport const GoogleMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'bounds_changed',\r\n    centerchanged :     'center_changed',\r\n    zoomchanged :       'zoom_changed',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'closeclick'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { Extender } from '../extender';\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEndEvent: GoogleMapTypes.MapsEventListener;\r\n    private _mapResizeEvent: GoogleMapTypes.MapsEventListener;\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: GoogleMapTypes.MouseEvent): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.latLng) { return null; }\r\n        if (!e.latLng.lat || !e.latLng.lng) { return null; }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new google.maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        o.zIndex = 100000;\r\n        const label: MapLabel = new GoogleMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * Called when the custom overlay is added to the map. Triggers Onload....\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnAdd(): void {\r\n        super.OnAdd();\r\n        this.OnLoad();\r\n        this._canvas.style.zIndex = '100';\r\n            // move the canvas above primitives such as polygons.\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Called whenever the canvas needs to be redrawn. This method does not do the actual\r\n     * update, it simply scales the canvas. The actual redraw happens once the map is idle.\r\n     * @memberof GoogleCanvasOverly\r\n     * @method\r\n     */\r\n    public OnDraw(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = this.GetMap();\r\n\r\n        if (isStreetView) {\r\n            // Don't show the canvas if the map is in Streetside mode.\r\n            this._canvas.style.display = 'none';\r\n        }\r\n        else {\r\n            // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n            // Upon idle or drag end, we can then redraw the canvas....\r\n            const zoomCurrent: number = map.getZoom();\r\n            const centerCurrent: GoogleMapTypes.LatLng = map.getCenter();\r\n\r\n            // Calculate map scale based on zoom level difference.\r\n            const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n            // Calculate the scaled dimensions of the canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const newWidth: number = w * scale;\r\n            const newHeight: number = h * scale;\r\n\r\n            // Calculate offset of canvas based on zoom and center offsets.\r\n            const projection = (<any>this).getProjection();\r\n            const cc = projection.fromLatLngToDivPixel(centerCurrent);\r\n\r\n            // Update the canvas CSS position and dimensions.\r\n            this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnLoad(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        const c: GoogleMapTypes.LatLng = map.getCenter();\r\n        this._centerStart = {\r\n            latitude: c.lat(),\r\n            longitude: c.lng()\r\n        };\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = google.maps.event.addListener(map, 'resize', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Associates the cnavas overlay with a map.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            if (el != null) {\r\n                panes.overlayLayer.appendChild(el);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n            }\r\n            else {\r\n                panes.overlayLayer.removeChild(this._canvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        if (this._viewChangeEndEvent) { google.maps.event.removeListener(this._viewChangeEndEvent); }\r\n        if (this._mapResizeEvent) { google.maps.event.removeListener(this._mapResizeEvent); }\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        const el: HTMLDivElement = map.getDiv();\r\n        this._canvas.width = el.offsetWidth;\r\n        this._canvas.height = el.offsetHeight;\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (true) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const centerPoint = (<any>this).getProjection().fromLatLngToDivPixel(map.getCenter());\r\n            this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            const c: GoogleMapTypes.LatLng = map.getCenter();\r\n            this._centerStart = {\r\n                latitude: c.lat(),\r\n                longitude: c.lng()\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n\r\n    new Extender(GoogleCanvasOverlay)\r\n        .Extend(new google.maps.OverlayView)\r\n        .Map('onAdd', 'OnAdd')\r\n        .Map('draw', 'OnDraw')\r\n        .Map('onRemove', 'OnRemove');\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { MapService } from './map.service';\r\nimport { MarkerService } from './marker.service';\r\nimport { InfoBoxService } from './infobox.service';\r\nimport { LayerService } from './layer.service';\r\nimport { ClusterService } from './cluster.service';\r\nimport { PolygonService } from './polygon.service';\r\nimport { PolylineService } from './polyline.service';\r\n\r\n/**\r\n * Implements a factory to create all the implementation specifc services for a map implementation\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapServiceFactory {\r\n\r\n    /**\r\n     * Creates the map service.\r\n     *\r\n     * @abstract\r\n     * @returns - {@link MapService} implementing a specific underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract Create(): MapService;\r\n\r\n    /**\r\n     * Creates the cluster service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link ClusterService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateClusterService(map: MapService): ClusterService;\r\n\r\n    /**\r\n     * Creates the info box service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param marker - {@link MarkerService} implementation for thh underlying marker archticture.\r\n     * @returns - {@link InfoBoxService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateInfoBoxService(map: MapService, marker: MarkerService): InfoBoxService;\r\n\r\n    /**\r\n     * Creates the layer service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link LayerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateLayerService(map: MapService): LayerService;\r\n\r\n    /**\r\n     * Creates the marker service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @param clusters  - {@link ClusterService} implementation for the underlying map architecture.\r\n     * @returns - {@link MarkerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateMarkerService(map: MapService, layers: LayerService, clusters: ClusterService): MarkerService;\r\n\r\n    /**\r\n     * Creates the polygon service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolygonService(map: MapService, layers: LayerService): PolygonService;\r\n\r\n    /**\r\n     * Creates the polyline service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolylineService(map: MapService, layers: LayerService): PolylineService;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { InfoWindow } from '../models/info-window';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * Abstract class to implement map api. A concrete implementation should be created for each\r\n * Map provider supported (e.g. Bing, Goolge, ESRI)\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapService {\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Gets the Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapInstance(): any;\r\n\r\n    /**\r\n     * Gets a Promise for a Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapPromise(): Promise<any>;\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapSize(): ISize;\r\n\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Gets a random geo locations filling the bounding box.\r\n     *\r\n     * @param count - number of locations to return\r\n     * @param bounds  - bounding box.\r\n     * @returns - Array of geo locations.\r\n     * @memberof MapService\r\n     */\r\n    public static GetRandonLocations(count: number, bounds: IBox): Array<ILatLong> {\r\n        const a: Array<ILatLong> = [];\r\n        const _getRandomLocation = (b: IBox) => {\r\n            const lat: number = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;\r\n            let lng: number = 0;\r\n            if (crossesDateLine) {\r\n                lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;\r\n                if (lng > 180) { lng = lng - 360; }\r\n            }\r\n            else {\r\n                lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;\r\n            }\r\n            const p: ILatLong = { latitude: lat, longitude: lng };\r\n            return p;\r\n        };\r\n        let crossesDateLine: boolean = false;\r\n\r\n        if (bounds == null) { bounds = <IBox>{\r\n                maxLatitude: 360,\r\n                minLatitude: 0,\r\n                maxLongitude: 170,\r\n                minLongitude: 0\r\n            };\r\n        }\r\n        if (bounds.center.longitude < bounds.minLongitude  || bounds.center.longitude > bounds.maxLongitude) { crossesDateLine = true; }\r\n        if (!count || count <= 0) {\r\n            return [_getRandomLocation(bounds)];\r\n        }\r\n        for (let r = 0; r < count; r++) { a.push(_getRandomLocation(bounds)); }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof MapService\r\n     * @abstract\r\n     */\r\n    public abstract CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay>;\r\n\r\n    /**\r\n     * Creates a map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateClusterLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying natvie infobox object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow>;\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void>;\r\n\r\n    /**\r\n     * Creates a map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying native pushpin object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMarker(options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates a polygon within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolygon(options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates a polyline within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DeleteLayer(layer: Layer): Promise<void>;\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DisposeMap(): void;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounds\r\n     *\r\n     * @returns - A promise that when fullfilled contains the bounding box of the screen. See {@link IBox}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetBounds(): Promise<IBox>;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetCenter(): Promise<ILatLong>;\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetZoom(): Promise<number>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationToPoint(loc: ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>>;\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetCenter(latLng: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetMapOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetViewOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetZoom(zoom: number): Promise<void>;\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SubscribeToMapEvent<E>(eventName: string): Observable<E>;\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract TriggerMapEvent(eventName: string): Promise<void>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Marker } from '../models/marker';\r\nimport { MapMarkerDirective } from '../components/map-marker';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MarkerService {\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract AddMarker(marker: MapMarkerDirective): void;\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T>;\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @abstract\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract DeleteMarker(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: MouseEvent| any): ILatLong;\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetNativeMarker(marker: MapMarkerDirective): Promise<Marker>;\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetPixelsFromClick(e: MouseEvent| any): IPoint;\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @abstract\r\n     * @param target - Either a {@link MapMarkerDirective} or a {@link ILatLong}\r\n     * for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarkerDirective or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateAnchor(maker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateDraggable(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateIcon(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateLabel(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateTitle(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visibility.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateVisible(marker: MapMarkerDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { InfoBoxComponent } from '../components/infobox';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoWindow } from '../models/info-window';\r\n\r\n/**\r\n * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class InfoBoxService {\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract AddInfoWindow(info: InfoBoxComponent): void;\r\n\r\n    /**\r\n     * Closes an infobox that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Close(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Subscribe to events on the infowindow.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract CreateEventObservable<T>(event: string, infoBoxComponent: InfoBoxComponent): Observable<T>;\r\n\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract DeleteInfoWindow(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void>;\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param latlng - The position to set\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetPosition(info: InfoBoxComponent, latlng?: ILatLong): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { Layer } from '../models/layer';\r\nimport { MapLayerDirective } from '../components/map-layer';\r\n\r\n/**\r\n * Abstract class to to define the layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class LayerService {\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Adds a marker to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the marker.\r\n     * @param options - Marker options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Marker model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @abstract\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>>;\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polygon options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>>;\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polylines for complex paths) model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolyline(layer: number, options: IPolygonOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>>;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract DeleteLayer(layer: MapLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object or MapLayerId for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapPolygonDirective } from '../components/map-polygon';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolygonService {\r\n\r\n  /**\r\n   * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} to be added.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract AddPolygon(polygon: MapPolygonDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polygon.\r\n    *\r\n    * @abstract\r\n    * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polygon has been deleted.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract DeletePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon>;\r\n\r\n  /**\r\n   * Set the polygon options.\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polygon options have been set.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polygon path\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polygon has been updated.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract UpdatePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapPolylineDirective } from '../components/map-polyline';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolylineService {\r\n\r\n  /**\r\n   * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} to be added.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract AddPolyline(polyline: MapPolylineDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polyline.\r\n    *\r\n    * @abstract\r\n    * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polyline has been deleted.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract DeletePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polyline model for the polyline allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polyline} implementation (or an\r\n   * array of polylines) for complex paths of the underlying platform.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>>;\r\n\r\n  /**\r\n   * Set the polyline options.\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polyline options have been set.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polyline path\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polyline has been updated.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract UpdatePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { ClusterLayerDirective } from '../components/cluster-layer';\r\nimport { LayerService } from './layer.service';\r\n\r\n/**\r\n * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class ClusterService extends LayerService {\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StartClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StopClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n}\r\n","import { Directive, Input, Output, EventEmitter } from '@angular/core';\r\n\r\n/**\r\n * InfoBoxAction renders an action in an info window {@link InfoBox}\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n *  `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box>\r\n *          <x-info-box-action [Label]=\"actionlabel\" (ActionClicked)=\"actionClicked(this)\"></x-info-box-action>\r\n *        </x-info-box>\r\n *      </x-map-marker>\r\n *    </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-info-box-action'\r\n})\r\nexport class InfoBoxActionDirective {\r\n\r\n    /**\r\n     * The label to display on the action\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Input()\r\n    Label: string;\r\n\r\n    /**\r\n     * Emits an event when the action has been clicked\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Output()\r\n    ActionClicked: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n}\r\n","import {\r\n    AfterViewInit,\r\n    Component,\r\n    ContentChildren,\r\n    ElementRef,\r\n    EventEmitter,\r\n    Input,\r\n    OnChanges,\r\n    OnDestroy,\r\n    Output,\r\n    QueryList,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ViewEncapsulation\r\n} from '@angular/core';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { InfoBoxActionDirective } from './infobox-action';\r\n\r\n/**\r\n * internal counter to use as ids for multiple infoboxes.\r\n */\r\nlet infoBoxId = 0;\r\n\r\n/**\r\n * InfoBox renders a info window inside a {@link MapMarkerDirective} or standalone.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box [DisableAutoPan]=\"true\">\r\n *          Hi, this is the content of the <strong>info window</strong>\r\n *         </x-info-box>\r\n *       </x-map-marker>\r\n *     </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-info-box',\r\n    template: `\r\n        <div #infoBoxContent class='info-box-content'>\r\n            <ng-content></ng-content>\r\n        </div>`,\r\n    styles: [`\r\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None\r\n})\r\nexport class InfoBoxComponent implements OnDestroy, OnChanges, AfterViewInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _infoBoxAddedToManager = false;\r\n    private _id: string = (infoBoxId++).toString();\r\n\r\n    /**\r\n     * HTML conent of the infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ViewChild('infoBoxContent') private _content: ElementRef;\r\n\r\n    /**\r\n     * Zero or more actions to show on the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ContentChildren(InfoBoxActionDirective) public InfoWindowActions: QueryList<InfoBoxActionDirective>;\r\n\r\n\r\n    /**\r\n     * The latitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * The title to display in the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * The description to display in the info window.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Description: string;\r\n\r\n    /**\r\n     * Disable auto-pan on open. By default, the info window will pan the map so that it is fully\r\n     * visible when it opens.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public DisableAutoPan: boolean;\r\n\r\n    /**\r\n     *  Maximum width of the infowindow, regardless of content's width. This value is only considered\r\n     *  if it is set before a call to open. To change the maximum width when changing content, call\r\n     *  close, update maxWidth, and then open.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public MaxWidth: number;\r\n\r\n    /**\r\n     * Determine whether only one infobox can be open at a time. Note that ANY info box settings.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Modal = true;\r\n\r\n    /**\r\n     * Holds the marker that is the host of the info window (if available)\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public HostMarker: MapMarkerDirective;\r\n\r\n    /**\r\n     * Determines visibility of infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Visible = false;\r\n\r\n    /**\r\n     * Horizontal offset of the infobox from the host marker lat/long or the sepecified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public xOffset: number;\r\n\r\n    /**\r\n     * Vertical offset for the infobox from the host marker lat/long or the specified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public yOffset: number;\r\n\r\n    /**\r\n     * Determines if other info boxes should be closed before opening this one\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public CloseInfoBoxesOnOpen = true;\r\n\r\n    ///\r\n    /// Delegate defintions\r\n    ///\r\n\r\n    /**\r\n     * Emits an event when the info window is closed.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Output() public InfoBoxClose: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the HTML content of the info box.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get HtmlContent(): string {\r\n        if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {\r\n            return this._content.nativeElement.outerHTML;\r\n        }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Gets the Id of the info box as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of InfoBoxComponent.\r\n     * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    constructor(private _infoBoxService: InfoBoxService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Closes the Infobox.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Close(): Promise<void> {\r\n        return this._infoBoxService.Close(this).then(() => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on after component view as been initialized. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngAfterViewInit() {\r\n        this._infoBoxService.AddInfoWindow(this);\r\n        this._infoBoxAddedToManager = true;\r\n        this.HandleEvents();\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (!this._infoBoxAddedToManager) { return; }\r\n        if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&\r\n            typeof this.Longitude === 'number') {\r\n            this._infoBoxService.SetPosition(this, {\r\n                latitude: changes['latitude'].currentValue,\r\n                longitude: changes['longitude'].currentValue\r\n            });\r\n        }\r\n        this.SetInfoWindowOptions(changes);\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnDestroy() { this._infoBoxService.DeleteInfoWindow(this); }\r\n\r\n    /**\r\n     * Opens a closed info window.\r\n     *\r\n     * @param [loc]  - {@link ILatLong } representing position on which to open the window.\r\n     * @returns - Promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Open(loc?: ILatLong): Promise<void> {\r\n        return this._infoBoxService.Open(this, loc);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the info box.\r\n     *\r\n     * @returns - string representation of the info box.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public ToString(): string { return 'InfoBoxComponent-' + this._id; }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleEvents(): void {\r\n        this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(e => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param changes\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    private SetInfoWindowOptions(changes: { [key: string]: SimpleChange }) {\r\n        const options: IInfoWindowOptions = {};\r\n        if (changes['title']) { options.title = this.Title; }\r\n        if (changes['description']) { options.description = this.Description; }\r\n        if (changes['disableAutoPan']) { options.disableAutoPan = this.DisableAutoPan; }\r\n        if (changes['visible']) { options.visible = this.Visible; }\r\n        if (changes['xOffset'] || changes['yOffset']) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            options.pixelOffset.x = this.xOffset;\r\n            options.pixelOffset.y = this.yOffset;\r\n        }\r\n        this._infoBoxService.SetOptions(this, options);\r\n    }\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef\r\n} from '@angular/core';\r\nimport { Subscription, timer } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet markerId = 0;\r\n\r\n/**\r\n * MapMarkerDirective renders a map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\"></x-map-marker>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker'\r\n})\r\nexport class MapMarkerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clickTimeout: Subscription = null;\r\n    private _events: Subscription[] = [];\r\n    private _id: string;\r\n    private _inClusterLayer = false;\r\n    private _inCustomLayer = false;\r\n\r\n    /**\r\n     * Any InfoBox that is a direct children of the marker\r\n     *\r\n     * @protected\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n    private _layerId: number;\r\n    private _markerAddedToManger = false;\r\n\r\n    /**\r\n     *  Icon anchor relative to marker root\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Anchor: IPoint;\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * If true, the marker can be dragged. Default value is false.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when a marker icon is being created.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * Icon height\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Height: number;\r\n\r\n    /**\r\n     * Information for dynamic, custom created icons.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Icon (the URL of the image) for the foreground.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconUrl: string;\r\n\r\n    /**\r\n     * True to indiciate whether this is the first marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsFirstInSet = false;\r\n\r\n    /**\r\n     * True to indiciate whether this is the last marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsLastInSet = true;\r\n\r\n    /**\r\n     * The label (a single uppercase character) for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Label: string;\r\n\r\n    /**\r\n     * The latitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Marker. This is useful for events\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseout.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseover.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This even is fired when the marker is right-clicked on.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     *  The title of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Sets the visibility of the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Icon Width\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Width: number;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Getswhether the marker has already been added to the marker service and is ready for use.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get AddedToManager(): boolean { return this._markerAddedToManger; }\r\n\r\n    /**\r\n     * Gets the id of the marker as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a cluster layer. See {@link ClusterLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InClusterLayer(): boolean { return this._inClusterLayer; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the marker belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _containerRef - View container hosting the marker.\r\n     * Used to determine parent layer through markup.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    constructor(private _markerService: MarkerService, private _containerRef: ViewContainerRef) {\r\n        this._id = (markerId++).toString();\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a marker geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates. If null, the marker's coordinates are used.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public LocationToPixel(loc?: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc ? loc : this);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        if (this._infoBox != null) { this._infoBox.HostMarker = this; }\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-cluster-layer') {\r\n                this._inClusterLayer = true;\r\n            } else if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n            }\r\n            this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n        }\r\n        if (!this._markerAddedToManger) {\r\n            this._markerService.AddMarker(this);\r\n            this._markerAddedToManger = true;\r\n            this.AddEventListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {\r\n            return;\r\n        }\r\n        if (!this._markerAddedToManger) { return; }\r\n        if (changes['Latitude'] || changes['Longitude']) {\r\n            this._markerService.UpdateMarkerPosition(this);\r\n        }\r\n        if (changes['Title']) {\r\n            this._markerService.UpdateTitle(this);\r\n        }\r\n        if (changes['Label']) {\r\n            this._markerService.UpdateLabel(this);\r\n        }\r\n        if (changes['Draggable']) {\r\n            this._markerService.UpdateDraggable(this);\r\n        }\r\n        if (changes['IconUrl'] || changes['IconInfo']) {\r\n            this._markerService.UpdateIcon(this);\r\n        }\r\n        if (changes['Anchor']) {\r\n            this._markerService.UpdateAnchor(this);\r\n        }\r\n        if (changes['Visible']) {\r\n            this._markerService.UpdateVisible(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._markerService.DeleteMarker(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public toString(): string { return 'MapMarker-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    private AddEventListeners(): void {\r\n        const _getEventArg: (e: MouseEvent) => IMarkerEvent = e => {\r\n            return {\r\n                Marker: this,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            };\r\n        };\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('click', this).subscribe((e: MouseEvent) => {\r\n            ///\r\n            /// this is necessary since map will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = timer(300).subscribe(n => {\r\n                if (this._infoBox != null) {\r\n                    this._infoBox.Open(this._markerService.GetCoordinatesFromClick(e));\r\n                }\r\n                this.MarkerClick.emit(_getEventArg(e));\r\n            });\r\n        }));\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe((e: MouseEvent) => {\r\n            if (this._clickTimeout) {\r\n                this._clickTimeout.unsubscribe();\r\n                this._clickTimeout = null;\r\n            }\r\n            this.DblClick.emit(_getEventArg(e));\r\n        }));\r\n\r\n        const handlers = [\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._markerService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Component,\r\n    EventEmitter,\r\n    OnChanges,\r\n    OnInit,\r\n    OnDestroy,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ContentChildren,\r\n    Input,\r\n    Output,\r\n    ElementRef,\r\n    HostBinding,\r\n    ViewEncapsulation,\r\n    ChangeDetectionStrategy,\r\n    NgZone,\r\r\n    AfterViewInit\n} from '@angular/core';\r\nimport { MapServiceFactory } from '../services/mapservicefactory';\r\nimport { MapService } from '../services/map.service';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { MapTypeId } from '../models/map-type-id';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * Renders a map based on a given provider.\r\n * **Important note**: To be able see a map in the browser, you have to define a height for the CSS\r\n * class `map-container`.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\"></x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-map',\r\n    providers: [\r\n        { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },\r\n        { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },\r\n        {\r\n            provide: InfoBoxService, deps: [MapServiceFactory, MapService,\r\n                MarkerService], useFactory: InfoBoxServiceFactory\r\n        },\r\n        { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },\r\n        { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },\r\n        { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },\r\n        { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }\r\n    ],\r\n    template: `\r\n        <div #container class='map-container-inner'></div>\r\n        <div class='map-content'>\r\n            <ng-content></ng-content>\r\n        </div>\r\n    `,\r\n    styles: [`\r\n        .map-container-inner { width: inherit; height: inherit; }\r\n        .map-container-inner div { background-repeat: no-repeat; }\r\n        .map-content { display:none; }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None,\r\n    changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class MapComponent implements OnChanges, OnInit, OnDestroy, AfterViewInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _longitude = 0;\r\n    private _latitude = 0;\r\n    private _zoom = 0;\r\n    private _clickTimeout: number | NodeJS.Timer;\r\n    private _options: IMapOptions = {};\r\n    private _box: IBox = null;\r\n    private _mapPromise: Promise<void>;\r\n    @HostBinding('class.map-container') public _containerClass = true;\r\n    @ViewChild('container') private _container: ElementRef;\r\n    @ContentChildren(MapMarkerDirective) private _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Get or sets the maximum and minimum bounding box for map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Box(): IBox { return this._box; }\r\n    public set Box(val: IBox) { this._box = val; }\r\n\r\n    /**\r\n     * Gets or sets the latitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Latitude(): number | string { return this._longitude; }\r\n    public set Latitude(value: number | string) {\r\n        this._latitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the longitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Longitude(): number | string { return this._longitude; }\r\n    public set Longitude(value: number | string) {\r\n        this._longitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets general map Options\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Options(): IMapOptions { return this._options; }\r\n    public set Options(val: IMapOptions) { this._options = val; }\r\n\r\n    /**\r\n     * Gets or sets the zoom level of the map. The default value is `8`.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Zoom(): number | string { return this._zoom; }\r\n    public set Zoom(value: number | string) {\r\n        this._zoom = this.ConvertToDecimal(value, 8);\r\n        if (typeof this._zoom === 'number') {\r\n            this._mapService.SetZoom(this._zoom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This event emitter is fired when the map bounding box changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    BoundsChange: EventEmitter<IBox> = new EventEmitter<IBox>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map center changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    CenterChange: EventEmitter<ILatLong> = new EventEmitter<ILatLong>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the map (but not when they click on a\r\n     * marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapDblClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user right-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapRightClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOver: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOut: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseMove: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * The event emitter is fired when the map service is available and the maps has been\r\n     * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns\r\n     * the main map object of the underlying platform.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapPromise: EventEmitter<Promise<any>> = new EventEmitter<Promise<any>>();\r\n\r\n    /**\r\n     * This event emiiter is fired when the map zoom changes\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    ZoomChange: EventEmitter<Number> = new EventEmitter<Number>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map service is available and the maps has been\r\n     * Initialized\r\n     * @memberOf MapComponent\r\n     */\r\n    @Output()\r\n    MapService: EventEmitter<MapService> = new EventEmitter<MapService>();\r\n\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapComponent.\r\n     *\r\n     * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.\r\n     *                                   Generally provided via injections.\r\n     * @memberof MapComponent\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnInit(): void {\r\n        this.MapPromise.emit(this._mapService.MapPromise);\r\n        this.MapService.emit(this._mapService);\r\n    }\r\n\r\n    /**\r\n     * Called after Angular has fully initialized a component's view. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngAfterViewInit(): void {\r\n        this.InitMapInstance(this._container.nativeElement);\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (this._mapPromise) {\r\n            if (changes['Box']) {\r\n                if (this._box != null) {\r\n                    this._mapService.SetViewOptions(<IMapOptions>{\r\n                        bounds: this._box\r\n                    });\r\n                }\r\n            }\r\n            if (changes['Options']) {\r\n                this._mapService.SetMapOptions(this._options);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._mapService.DisposeMap();\r\n    }\r\n\r\n    /**\r\n     * Triggers a resize event on the map instance.\r\n     *\r\n     * @returns - A promise that gets resolved after the event was triggered.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public TriggerResize(): Promise<void> {\r\n        // Note: When we would trigger the resize event and show the map in the same turn (which is a\r\n        // common case for triggering a resize event), then the resize event would not\r\n        // work (to show the map), so we trigger the event in a timeout.\r\n        return new Promise<void>((resolve) => {\r\n            setTimeout(\r\n                () => { return this._mapService.TriggerMapEvent('resize').then(() => resolve()); });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods.\r\n    ///\r\n\r\n    /**\r\n     * Converts a number-ish value to a number.\r\n     *\r\n     * @param value - The value to convert.\r\n     * @param [defaultValue=null] - Default value to use if the conversion cannot be performed.\r\n     * @returns - Converted number of the default.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private ConvertToDecimal(value: string | number, defaultValue: number = null): number {\r\n        if (typeof value === 'string') {\r\n            return parseFloat(value);\r\n        } else if (typeof value === 'number') {\r\n            return <number>value;\r\n        }\r\n        return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapClickEvents(): void {\r\n        this._mapService.SubscribeToMapEvent<any>('click').subscribe(e => {\r\n            //\r\n            // this is necessary since bing will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = setTimeout(() => {\r\n                this.MapClick.emit(<MouseEvent>e);\r\n            }, 300);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('dblclick').subscribe(e => {\r\n            if (this._clickTimeout) {\r\n                clearTimeout(<NodeJS.Timer>this._clickTimeout);\r\n            }\r\n            this.MapDblClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('rightclick').subscribe(e => {\r\n            this.MapRightClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseover').subscribe(e => {\r\n            this.MapMouseOver.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseout').subscribe(e => {\r\n            this.MapMouseOut.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mousemove').subscribe(e => {\r\n            this.MapMouseMove.emit(<MouseEvent>e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapBoundsChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('boundschanged').subscribe(() => {\r\n            this._mapService.GetBounds().then((bounds: IBox) => {\r\n                this.BoundsChange.emit(bounds);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapCenterChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('centerchanged').subscribe(() => {\r\n            this._mapService.GetCenter().then((center: ILatLong) => {\r\n                if (this._latitude !== center.latitude || this._longitude !== center.longitude) {\r\n                    this._latitude = center.latitude;\r\n                    this._longitude = center.longitude;\r\n                    this.CenterChange.emit(<ILatLong>{ latitude: this._latitude, longitude: this._longitude });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map zoom change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapZoomChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('zoomchanged').subscribe(() => {\r\n            this._mapService.GetZoom().then((z: number) => {\r\n                if (this._zoom !== z) {\r\n                    this._zoom = z;\r\n                    this.ZoomChange.emit(z);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes the map.\r\n     *\r\n     * @param el - Html elements which will host the map canvas.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private InitMapInstance(el: HTMLElement) {\r\n        this._zone.runOutsideAngular(() => {\r\n            if (this._options.center == null) { this._options.center = { latitude: this._latitude, longitude: this._longitude }; }\r\n            if (this._options.zoom == null) { this._options.zoom = this._zoom; }\r\n            if (this._options.mapTypeId == null) { this._options.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._box != null) { this._options.bounds = this._box; }\r\n            this._mapPromise = this._mapService.CreateMap(el, this._options);\r\n            this.HandleMapCenterChange();\r\n            this.HandleMapBoundsChange();\r\n            this.HandleMapZoomChange();\r\n            this.HandleMapClickEvents();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the map center based on the geo properties of the component.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private UpdateCenter(): void {\r\n        if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {\r\n            return;\r\n        }\r\n        this._mapService.SetCenter({\r\n            latitude: this._latitude,\r\n            longitude: this._longitude,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Cluster Service based on the underlying map architecture\r\n */\r\nexport function ClusterServiceFactory(f: MapServiceFactory, m: MapService): ClusterService { return f.CreateClusterService(m); }\r\n\r\n/**\r\n * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param m - A {@link MarkerService} instance.\r\n * @returns - A concrete instance of a InfoBox Service based on the underlying map architecture.\r\n */\r\nexport function InfoBoxServiceFactory(f: MapServiceFactory, m: MapService,\r\n    ma: MarkerService): InfoBoxService { return f.CreateInfoBoxService(m, ma); }\r\n\r\n/**\r\n * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Layer Service based on the underlying map architecture.\r\n */\r\nexport function LayerServiceFactory(f: MapServiceFactory, m: MapService): LayerService { return f.CreateLayerService(m); }\r\n\r\n/**\r\n * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @returns - A concrete instance of a MapService based on the underlying map architecture.\r\n */\r\nexport function MapServiceCreator(f: MapServiceFactory): MapService { return f.Create(); }\r\n\r\n/**\r\n * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @param c - A {@link ClusterService} instance.\r\n * @returns - A concrete instance of a Marker Service based on the underlying map architecture.\r\n */\r\nexport function MarkerServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService, c: ClusterService): MarkerService {\r\n    return f.CreateMarkerService(m, l, c);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polygon Service based on the underlying map architecture.\r\n */\r\nexport function PolygonServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolygonService {\r\n    return f.CreatePolygonService(m, l);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polyline Service based on the underlying map architecture.\r\n */\r\nexport function PolylineServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolylineService {\r\n    return f.CreatePolylineService(m, l);\r\n}\r\n","import { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, AfterContentInit, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * internal counter to use as ids for multiple layers.\r\n */\r\nlet layerId = 0;\r\n\r\n/**\r\n * MapLayerDirective creates a layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-map-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-map-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-layer'\r\n})\r\nexport class MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _visible = true;\r\n    protected _addedToManager = false;\r\n    protected _id: number;\r\n\r\n    @ContentChildren(MapMarkerDirective) protected _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the layer visibility.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    @Input()\r\n        public get Visible(): boolean { return this._visible; }\r\n        public set Visible(val: boolean) { this._visible = val; }\r\n\r\n    /**\r\n     * Gets the layer id.\r\n     *\r\n     * @readonly\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapLayerDirective.\r\n     * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.\r\n     * Generally provided via injections.\r\n     * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    constructor(protected _layerService: LayerService, protected _containerRef: ViewContainerRef) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnInit(): void {\r\n        this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();\r\n        this._layerService.AddLayer(this);\r\n        this._addedToManager = true;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['Visible']) {\r\n            this._layerService.GetNativeLayer(this).then(l => {\r\n                l.SetVisible(!l.GetVisible());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._layerService.DeleteLayer(this);\r\n    }\r\n}\r\n","import { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { IMarkerIconInfo} from '../interfaces/imarker-icon-info';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ISpiderClusterOptions } from '../interfaces/ispider-cluster-options';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { MapLayerDirective } from './map-layer';\r\n\r\n/**\r\n *\r\n * Creates a cluster layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-cluster-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-cluster-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-cluster-layer'\r\n})\r\nexport class ClusterLayerDirective extends MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clusteringEnabled = true;\r\n    private _clusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n    private _clusterClickAction: ClusterClickAction = ClusterClickAction.ZoomIntoCluster;\r\n    private _spiderClusterOptions: ISpiderClusterOptions;\r\n    private _zIndex: number;\r\n    private _gridSize: number;\r\n    private _layerOffset: IPoint;\r\n    private _iconInfo: IMarkerIconInfo;\r\n    private _minimumClusterSize: number;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _zoomOnClick = true;\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n\r\n    ///\r\n    /// Property defintions\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterClickAction(): ClusterClickAction  { return this._clusterClickAction; }\r\n        public set ClusterClickAction(val: ClusterClickAction) { this._clusterClickAction = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the clustering layer enables clustering. When set to false, the layer\r\n     * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusteringEnabled(): boolean  { return this._clusteringEnabled; }\r\n        public set ClusteringEnabled(val: boolean) { this._clusteringEnabled = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterPlacementMode(): ClusterPlacementMode  { return this._clusterPlacementMode; }\r\n        public set ClusterPlacementMode(val: ClusterPlacementMode) { this._clusterPlacementMode = val; }\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get GridSize(): number  { return this._gridSize; }\r\n        public set GridSize(val: number) { this._gridSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get IconInfo(): IMarkerIconInfo  { return this._iconInfo; }\r\n        public set IconInfo(val: IMarkerIconInfo) { this._iconInfo = val; }\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get LayerOffset(): IPoint  { return this._layerOffset; }\r\n        public set LayerOffset(val: IPoint) { this._layerOffset = val; }\r\n\r\n    /**\r\n     * Gets or sets the minimum pins required to form a cluster\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get MinimumClusterSize(): number  { return this._minimumClusterSize; }\r\n        public set MinimumClusterSize(val: number) { this._minimumClusterSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get SpiderClusterOptions(): ISpiderClusterOptions { return this._spiderClusterOptions; }\r\n        public set SpiderClusterOptions(val: ISpiderClusterOptions) { this._spiderClusterOptions = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZIndex(): number { return this._zIndex; }\r\n        public set ZIndex(val: number) { this._zIndex = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZoomOnClick(): boolean { return this._zoomOnClick; }\r\n        public set ZoomOnClick(val: boolean) { this._zoomOnClick = val; }\r\n\r\n    /**\r\n     * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.\r\n     *\r\n     * @param size - The number of markers in the cluster.\r\n     * @param info  - The icon info to be used. This will be hydrated with\r\n     * the actualy dimensions of the created markers and is used by the underlying model/services\r\n     * to correctly offset the marker for correct positioning.\r\n     * @param baseMarkerSize - The base size for dynmic markers.\r\n     * @param ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.\r\n     * @returns - An string containing the SVG for the marker.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public static CreateDynamicSizeMarker(size: number, info: IMarkerIconInfo,\r\n                                             baseMarkerSize: number, ranges: Map<number, string>): string {\r\n        const mr: number = baseMarkerSize;\r\n        const outline: number = mr * 0.35;\r\n        const total: number = size;\r\n        const r: number = Math.log(total) / Math.log(10) * 5 + mr;\r\n        const d: number = r * 2;\r\n        let fillColor: string;\r\n        ranges.forEach((v, k) => {\r\n            if (total <= k && !fillColor) { fillColor = v; }\r\n        });\r\n        if (!fillColor) { fillColor = 'rgba(20, 180, 20, 0.5)'; }\r\n\r\n        // Create an SVG string of two circles, one on top of the other, with the specified radius and color.\r\n        const svg: Array<any> = [`<svg xmlns='http://www.w3.org/2000/svg' width='${d}' height='${d}'>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r}' fill='${fillColor}'/>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r - outline}' fill='${fillColor}'/>`,\r\n            `</svg>`];\r\n        info.size = { width: d, height: d };\r\n        info.markerOffsetRatio = { x: 0.5, y: 0.5 };\r\n        info.textOffset = { x: 0, y: r - 8 };\r\n        return svg.join('');\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of ClusterLayerDirective.\r\n     *\r\n     * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps\r\n     * implementations. Generally provided via injections.\r\n     * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    constructor(_layerService: ClusterService, _containerRef: ViewContainerRef) {\r\n        super(_layerService, _containerRef);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['ClusterClickAction']) {\r\n            throw (\r\n                new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.')\r\n            );\r\n        }\r\n\r\n        const options: IClusterOptions = { id: this._id };\r\n        if (changes['ClusteringEnabled']) { options.clusteringEnabled = this._clusteringEnabled; }\r\n        if (changes['GridSize']) { options.gridSize = this._gridSize; }\r\n        if (changes['LayerOffset']) { options.layerOffset = this._layerOffset; }\r\n        if (changes['SpiderClusterOptions']) { options.spiderClusterOptions = this._spiderClusterOptions; }\r\n        if (changes['ZIndex']) { options.zIndex = this._zIndex; }\r\n        if (changes['Visible']) { options.visible = this._visible; }\r\n\r\n        this._layerService.GetNativeLayer(this).then((l: Layer) => {\r\n            l.SetOptions(options);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polygonId = 0;\r\n\r\n/**\r\n *\r\n * MapPolygonDirective renders a polygon inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolygonDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon [Paths]=\"path\"></x-map-polygon>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon'\r\n})\r\nexport class MapPolygonDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polygon\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polygon handles mouse events.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * The fill color of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillColor: string;\r\n\r\n    /**\r\n     * The fill opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillOpacity: number;\r\n\r\n    /**\r\n     * When true, edges of the polygon are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polygon are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polygon may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMinZoom: number;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polygon. This is useful for events\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a closed loop.\r\n     * Unlike polylines, a polygon may consist of one or more paths.\r\n     * As a result, the paths property may specify one or more arrays of\r\n     * LatLng coordinates. Paths are closed automatically; do not repeat the\r\n     * first vertex of the path as the last vertex. Simple polygons may be\r\n     * defined using a single array of LatLngs. More complex polygons may\r\n     * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.\r\n     * Inserting or removing LatLngs from the Array will automatically update\r\n     * the polygon on the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Paths: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title as the label on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowLabel: boolean;\r\n\r\n    /**\r\n     * Whether to show the title of the polygon as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polygon is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseout.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseover.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polygon\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n    /**\r\n     * This event is fired when the Polygon is right-clicked on.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when editing has completed.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() PathChanged: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polygon has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polygon as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polygon is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polygon belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonDirective.\r\n     * @param _polygonManager\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    constructor(private _polygonService: PolygonService, private _containerRef: ViewContainerRef) {\r\n        this._id = polygonId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polygonService.AddPolygon(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolygonOptions = this.GeneratePolygonChangeSet(changes);\r\n        if (o != null) { this._polygonService.SetOptions(this, o); }\r\n        if (changes['Paths'] && !changes['Paths'].isFirstChange()) {\r\n            this._polygonService.UpdatePolygon(this);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polygonService.DeletePolygon(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n        ///\r\n        /// remove event subscriptions\r\n        ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolygonEvent = e => {\r\n            return {\r\n                Polygon: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            const t: MapPolygonDirective = this;\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polygonService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        }));\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n            { name: 'pathchanged', handler: (ev: IPolygonEvent) => this.PathChanged.emit(ev) }\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polygonService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolygon option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolygonOptions} containing the polygon options.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private GeneratePolygonChangeSet(changes: SimpleChanges): IPolygonOptions {\r\n        const options: IPolygonOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['FillColor'] || changes['FillOpacity']) {\r\n            options.fillColor = this.FillColor;\r\n            options.fillOpacity = this.FillOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['LabelMaxZoom']) { options.labelMaxZoom = this.LabelMaxZoom; hasOptions = true; }\r\n        if (changes['LabelMinZoom']) { options.labelMinZoom = this.LabelMinZoom; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['ShowLabel']) { options.showLabel = this.ShowLabel; hasOptions = true; }\r\n        if (changes['StrokeColor'] || changes['StrokeOpacity']) {\r\n            options.strokeColor = this.StrokeColor;\r\n            options.strokeOpacity = this.StrokeOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polylineId = 0;\r\n\r\n/**\r\n *\r\n * MapPolylineDirective renders a polyline inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolylineDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline [Paths]=\"path\"></x-map-polyline>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline'\r\n})\r\nexport class MapPolylineDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polyline\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polyline handles mouse events.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * When true, edges of the polyline are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polyline are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polyline may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polyline. This is useful for events\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a polyline.\r\n     * Simple polylines may be defined using a single array of LatLngs. More\r\n     * complex polylines may specify an array of arrays.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Path: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title of the polyline as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polyline is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseout.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseover.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polyline\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This even is fired when the Polyline is right-clicked on.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polyline has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polyline as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polyline is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polyline belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineDirective.\r\n     * @param _polylineManager\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    constructor(private _polylineService: PolylineService, private _containerRef: ViewContainerRef) {\r\n        this._id = polylineId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polylineService.AddPolyline(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolylineOptions = this.GeneratePolylineChangeSet(changes);\r\n        if (o != null) {\r\n            this._polylineService.SetOptions(this, o);\r\n        }\r\n        if (changes['Path'] && !changes['Path'].isFirstChange()) {\r\n            this._polylineService.UpdatePolyline(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polylineService.DeletePolyline(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n            ///\r\n            /// remove event subscriptions\r\n            ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolylineEvent = e => {\r\n            return {\r\n                Polyline: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._polylineService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polylineService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        });\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polylineService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolyline option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolylineOptions} containing the polyline options.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private GeneratePolylineChangeSet(changes: SimpleChanges): IPolylineOptions {\r\n        const options: IPolylineOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['StrokeColor']) { options.strokeColor = this.StrokeColor; hasOptions = true; }\r\n        if (changes['StrokeOpacity']) { options.strokeOpacity = this.StrokeOpacity; hasOptions = true; }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone\r\n} from '@angular/core';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Marker } from '../models/marker';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterLayerDirective } from './cluster-layer';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapMarkerLayerDirective performantly renders a large set of map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker-layer [MarkerOptions]=\"_markers\"></x-map-marker-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker-layer'\r\n})\r\nexport class MapMarkerLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n    private _streaming: boolean = false;\r\n    private _markers: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n    private _markersLast: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterClickAction: ClusterClickAction =  ClusterClickAction.ZoomIntoCluster;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterIconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()  public ClusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Determines whether the layer clusters. This property can only be set on creation of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public EnableClustering: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public GridSize: number = 150;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom marker images. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     *  IMarkerOptions array holding the marker info.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get MarkerOptions(): Array<IMarkerOptions> { return this._markers; }\r\n        public set MarkerOptions(val: Array<IMarkerOptions>) {\r\n            if (this._streaming) {\r\n                this._markersLast.push(...val.slice(0));\r\n                this._markers.push(...val);\r\n            }\r\n            else {\r\n                this._markers = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the\r\n     * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewMarkerOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewMarkerOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZoomOnClick: boolean = true;\r\n\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the dynamic icon for a marker is being created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a marker in the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging a marker.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerLayerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _clusterService - Concreate implementation of a {@link ClusterService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    constructor(\r\n        private _markerService: MarkerService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public LocationToPixel(loc: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible\r\n            };\r\n            if (!this.EnableClustering) {\r\n                this._layerService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._layerService;\r\n            }\r\n            else {\r\n                fakeLayerDirective.LayerOffset = this.LayerOffset;\r\n                fakeLayerDirective.ZIndex = this.ZIndex;\r\n                fakeLayerDirective.ClusteringEnabled = this.EnableClustering;\r\n                fakeLayerDirective.ClusterPlacementMode = this.ClusterPlacementMode;\r\n                fakeLayerDirective.GridSize = this.GridSize;\r\n                fakeLayerDirective.ClusterClickAction = this.ClusterClickAction;\r\n                fakeLayerDirective.IconInfo = this.ClusterIconInfo;\r\n                fakeLayerDirective.CustomMarkerCallback = this.CustomMarkerCallback;\r\n                fakeLayerDirective.UseDynamicSizeMarkers = this.UseDynamicSizeMarkers;\r\n                this._clusterService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._clusterService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._clusterService;\r\n            }\r\n            this._layerPromise.then(l => {\r\n                l.SetVisible(this.Visible);\r\n                if (this.MarkerOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdateMarkers());\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        let shouldSetOptions: boolean = false;\r\n        const o: IClusterOptions = {\r\n            id: this._id\r\n        };\r\n        if (changes['MarkerOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdateMarkers();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n            });\r\n        }\r\n        if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {\r\n            if ('StopClustering' in this._service) {\r\n                o.clusteringEnabled = this.EnableClustering;\r\n                shouldSetOptions = true;\r\n            }\r\n            else {\r\n                throw (new Error('You cannot change EnableClustering after the layer has been created.'));\r\n            }\r\n        }\r\n        if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {\r\n            o.placementMode = this.ClusterPlacementMode;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {\r\n            o.gridSize = this.GridSize;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {\r\n            o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;\r\n            shouldSetOptions = true;\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||\r\n            (changes['IconInfo'] && !changes['IconInfo'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n\r\n        if (shouldSetOptions) {\r\n            this._zone.runOutsideAngular(() => {\r\n                const fakeLayerDirective: any = {Id : this._id};\r\n                this._layerPromise.then(l => l.SetOptions(o));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public toString(): string { return 'MapMarkerLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param m - the marker for which to add the event.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    private AddEventListeners(m: Marker): void {\r\n        m.AddListener('click', (e: MouseEvent) => this.MarkerClick.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n        m.AddListener('dragend', (e: MouseEvent) => this.DragEnd.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the markers based on the marker options. This will place the markers on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     * @method\r\n     */\r\n    private UpdateMarkers(): void {\r\n        if (this._layerPromise == null) { return; }\r\n        this._layerPromise.then(l => {\r\n            const markers: Array<IMarkerOptions> = this._streaming ? this._markersLast.splice(0) : this._markers;\r\n\r\n            // generate the promise for the markers\r\n            const mp: Promise<Array<Marker>> = this._service.CreateMarkers(markers, this.IconInfo);\r\n\r\n            // set markers once promises are fullfilled.\r\n            mp.then(m => {\r\n                m.forEach(marker => {\r\n                     this.AddEventListeners(marker);\r\n                });\r\n                this._streaming ? l.AddEntities(m) : l.SetEntities(m);\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polygons.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolygonLayerDirective performantly renders a large set of polygons on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon-layer [PolygonOptions]=\"_polygons\"></x-map-polygon-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon-layer'\r\n})\r\nexport class MapPolygonLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polygons: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n    private _polygonsLast: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polygon labels.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polygon options representing the polygons in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolygonOptions(): Array<IPolygonOptions> { return this._polygons; }\r\n        public set PolygonOptions(val: Array<IPolygonOptions>) {\r\n            if (this._streaming) {\r\n                this._polygonsLast.push(...val.slice(0));\r\n                this._polygons.push(...val);\r\n            }\r\n            else {\r\n                this._polygons = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polygon titles as the labels on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polygosn as the tooltips on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolygonOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolygonOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() public PolygonClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonDblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polygon in a layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                this._layerPromise,\r\n                this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n            ]).then(values => {\r\n                values[0].SetVisible(this.Visible);\r\n                this._canvas = values[1];\r\n                this._canvas._canvasReady.then(b => {\r\n                    this._tooltip = this._canvas.GetToolTipOverlay();\r\n                    this.ManageTooltip(this.ShowTooltips);\r\n                });\r\n                if (this.PolygonOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdatePolygons());\r\n                }\r\n            });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolygonOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolygons();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolygonLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param p - the polygon for which to add the event.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polygon): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolygonClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolygonDblClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolygonMouseMove.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolygonMouseOut.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolygonMouseOver.emit({Polygon: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polygon labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polygon.Title && e.Polygon.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polygon.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polygons based on the polygon options. This will place the polygons on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolygons(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polygons: Array<IPolygonOptions> = this._streaming ? this._polygonsLast.splice(0) : this._polygons;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the markers\r\n            const lp: Promise<Array<Polygon>> = this._service.CreatePolygons(l.GetOptions().id, polygons);\r\n\r\n            // set markers once promises are fullfilled.\r\n            lp.then(p => {\r\n                p.forEach(poly => {\r\n                    if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                    this.AddEventListeners(poly);\r\n                });\r\n                this._streaming ? l.AddEntities(p) : l.SetEntities(p);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polylines.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolylineLayerDirective performantly renders a large set of polyline on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline-layer [PolygonOptions]=\"_polyline\"></x-map-polyline-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline-layer'\r\n})\r\nexport class MapPolylineLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polylines: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n    private _polylinesLast: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polyline labels.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polyline options representing the polylines in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolylineOptions(): Array<IPolylineOptions> { return this._polylines; }\r\n        public set PolylineOptions(val: Array<IPolylineOptions>) {\r\n            if (this._streaming) {\r\n                this._polylinesLast.push(...val.slice(0));\r\n                this._polylines.push(...val);\r\n            }\r\n            else {\r\n                this._polylines = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polylines titles as the labels on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polylines as the tooltips on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolylineOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolylineOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() public PolylineClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineDblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polyline in a layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the polyline layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                    this._layerPromise,\r\n                    this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n                ]).then(values => {\r\n                    values[0].SetVisible(this.Visible);\r\n                    this._canvas = values[1];\r\n                    this._canvas._canvasReady.then(b => {\r\n                        this._tooltip = this._canvas.GetToolTipOverlay();\r\n                        this.ManageTooltip(this.ShowTooltips);\r\n                    });\r\n                    if (this.PolylineOptions) {\r\n                        this._zone.runOutsideAngular(() => this.UpdatePolylines());\r\n                    }\r\n                });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolylineOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolylines();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Layer Id.\r\n     * @returns - string representation of the layer id.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolylineLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the polylines.\r\n     *\r\n     * @param p - the polyline for which to add the event.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polyline): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolylineClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolylineDblClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolylineMouseMove.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolylineMouseOut.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolylineMouseOver.emit({Polyline: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polyline labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polyline.Title && e.Polyline.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polyline.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolylines(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polylines: Array<IPolylineOptions> = this._streaming ? this._polylinesLast.splice(0) : this._polylines;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the polylines\r\n            const lp: Promise<Array<Polyline|Array<Polyline>>> = this._service.CreatePolylines(l.GetOptions().id, polylines);\r\n\r\n            // set polylines once promises are fullfilled.\r\n            lp.then(p => {\r\n                const y: Array<Polyline> = new Array<Polyline>();\r\n                p.forEach(poly => {\r\n                    if (Array.isArray(poly)) {\r\n                        let title: string = '';\r\n                        const centroids: Array<ILatLong> = new Array<ILatLong>();\r\n                        poly.forEach(x => {\r\n                            y.push(x);\r\n                            this.AddEventListeners(x);\r\n                            centroids.push(x.Centroid);\r\n                            if (x.Title != null && x.Title.length > 0 && title.length === 0) { title = x.Title; }\r\n                        });\r\n                        this._labels.push({loc: Polyline.GetPolylineCentroid(centroids), title: title});\r\n                    }\r\n                    else {\r\n                        y.push(poly);\r\n                        if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                        this.AddEventListeners(poly);\r\n                    }\r\n                });\r\n                this._streaming ? l.AddEntities(y) : l.SetEntities(y);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n/**\r\n * Abstract implementation. USed for defintion only and as a base to implement your\r\n * own provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapAPILoader {\r\n\r\n    /**\r\n     * Loads the necessary resources for a given map architecture.\r\n     *\r\n     * @abstract\r\n     * @returns - Promise fullfilled when the resources have been loaded.\r\n     *\r\n     * @memberof MapAPILoader\r\n     */\r\n    abstract Load(): Promise<void>;\r\n\r\n}\r\n\r\n/**\r\n * Document Reference service to assist with abstracting the availability of document. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class DocumentRef {\r\n\r\n    /**\r\n     * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof DocumentRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (document) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the document object of the current environment.\r\n     *\r\n     * @returns - The document object.\r\n     *\r\n     * @memberof DocumentRef\r\n     */\r\n    public GetNativeDocument(): any {\r\n        if (typeof (document) === 'undefined') {\r\n            return null;\r\n        }\r\n        return document;\r\n    }\r\n}\r\n\r\n/**\r\n * Window Reference service to assist with abstracting the availability of window. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class WindowRef {\r\n\r\n    /**\r\n     * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof WindowRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (window) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the window object of the current environment.\r\n     *\r\n     * @returns - The window object.\r\n     *\r\n     * @memberof WindowRef\r\n     */\r\n    public GetNativeWindow(): any {\r\n        if (typeof (window) === 'undefined') {\r\n            return null;\r\n        }\r\n        return window;\r\n    }\r\n}\r\n\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link BingMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoaderConfig  {\r\n\r\n    ///\r\n    /// API key for bing maps\r\n    ///\r\n    apiKey = '';\r\n\r\n    ///\r\n    /// Host and Path used for the `<script>` tag.\r\n    ///\r\n    hostAndPath = 'www.bing.com/api/maps/mapcontrol';\r\n\r\n    ///\r\n    /// Protocol used for the `<script>` tag.\r\n    ///\r\n    protocol: ScriptProtocol = ScriptProtocol.HTTPS;\r\n\r\n    ///\r\n    /// The branch to be used. Leave empty for production. Use experimental\r\n    ///\r\n    branch = '';\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public get Config(): BingMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of BingMapAPILoader.\r\n     * @param _config  - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     * Necessary because Bing Map V8 interacts with the document object.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: BingMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `angular2bingmaps${new Date().getMilliseconds()}`;\r\n        script.src = this.GetScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                resolve();\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Bing Map V8 scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.\r\n     * @returns - The url to be used to load the Bing Map scripts.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    private GetScriptSrc(callbackName: string): string {\r\n        const protocolType: ScriptProtocol = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const hostAndPath: string = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;\r\n        const queryParams: { [key: string]: string } = {\r\n            callback: callbackName\r\n        };\r\n        if (this._config.branch !== '') {\r\n            queryParams['branch'] = this._config.branch;\r\n        }\r\n        const params: string = Object.keys(queryParams)\r\n            .map((k: string, i: number) => {\r\n                let param = (i === 0) ? '?' : '&';\r\n                return param += `${k}=${queryParams[k]}`;\r\n            })\r\n            .join('');\r\n        return `${protocol}//${hostAndPath}${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxActionDirective } from '../../components/infobox-action';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoBoxService} contract for the Bing Maps V8 architecture.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingInfoBoxService implements InfoBoxService {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<InfoWindow>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingInfoBoxService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - An instance of NgZone to provide zone aware promises.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = {\r\n                latitude: info.Latitude,\r\n                longitude: info.Longitude\r\n            };\r\n        }\r\n        if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {\r\n            options.actions = [];\r\n            info.InfoWindowActions.forEach((action: InfoBoxActionDirective) => {\r\n                options.actions.push({\r\n                    label: action.Label,\r\n                    eventHandler: () => { action.ActionClicked.emit(null); }\r\n                });\r\n            });\r\n        }\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n\r\n        options.visible = info.Visible;\r\n        const infoPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes an InfoBoxComponent that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((w) => w.Close());\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(eventNameTranslated, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        const w = this._boxes.get(info);\r\n        if (w == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return w.then((i: InfoWindow) => {\r\n            return this._zone.run(() => {\r\n                i.Close();\r\n                this._boxes.delete(info);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes.\r\n            this._boxes.forEach((v: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    v.then(w => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n\r\n            if (info.Latitude && info.Longitude) {\r\n                w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });\r\n            }\r\n            else if (loc) {\r\n                ///\r\n                /// this situation is specifically used for cluster layers that use spidering.\r\n                ///\r\n                w.SetPosition(loc);\r\n            }\r\n            else if (info.HostMarker) {\r\n                w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });\r\n            }\r\n            w.Open();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetOptions(options));\r\n    }\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetPosition({\r\n            latitude: info.Latitude,\r\n            longitude: info.Longitude\r\n        }));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../../services/marker.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { LayerService } from '../../services/layer.service';\r\nimport { ClusterService } from '../../services/cluster.service';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarkerService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link BingClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n                private _layerService: LayerService,\r\n                private _clusterService: ClusterService,\r\n                private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n        if (marker.Width) { o.width = marker.Width; }\r\n        if (marker.Height) { o.height = marker.Height; }\r\n        if (marker.Anchor) { o.anchor = marker.Anchor; }\r\n        if (marker.Metadata) { o.metadata = marker.Metadata; }\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() =>\r\n                    observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarker} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        let p: Promise<void> = Promise.resolve();\r\n        if (m != null) {\r\n            p = m.then((ma: Marker) => {\r\n                if (marker.InClusterLayer) {\r\n                    this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                if (marker.InCustomLayer) {\r\n                    this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                return this._zone.run(() => {\r\n                    ma.DeleteMarker();\r\n                    this._markers.delete(marker);\r\n                });\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.primitive) {\r\n            return null;\r\n        }\r\n        if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {\r\n            return null;\r\n        }\r\n        const p: Microsoft.Maps.Pushpin = e.primitive;\r\n        const loc: Microsoft.Maps.Location = p.getLocation();\r\n        return { latitude: loc.latitude, longitude: loc.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarker} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        const loc: ILatLong = this.GetCoordinatesFromClick(e);\r\n        if (loc == null) {\r\n            return null;\r\n        }\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n        const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>(<BingMapService>\r\n            this._mapService).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n        if (p == null) { return null; }\r\n        return { x: p.x, y: p.y };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarker} or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        const payload = (m: Marker, icon: string, iconInfo: IMarkerIconInfo) => {\r\n            if (icon && icon !== '') {\r\n                m.SetIcon(icon);\r\n                marker.DynamicMarkerCreated.emit(iconInfo);\r\n            }\r\n        };\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const s = Marker.CreateMarker(marker.IconInfo);\r\n                if (typeof(s) === 'string') { return(payload(m, s, marker.IconInfo)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(m, x.icon, x.iconInfo));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return(m.SetIcon(marker.IconUrl));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visiblity.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observer, Observable } from 'rxjs';\r\n\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingConversions } from './bing-conversions';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { BingLayer } from '../../models/bing/bing-layer';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/bing/bing-label';\r\nimport { MixinCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { BingCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\n\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapService implements MapService {\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<Microsoft.Maps.Map>;\r\n    private _mapInstance: Microsoft.Maps.Map;\r\n    private _mapResolver: (value?: Microsoft.Maps.Map) => void;\r\n    private _config: BingMapAPILoaderConfig;\r\n    private _modules: Map<string, Object> = new Map<string, Object>();\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets an array of loaded Bong modules.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get LoadedModules(): Map<string, Object> { return this._modules; }\r\n\r\n    /**\r\n     * Gets the Bing Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapInstance(): Microsoft.Maps.Map { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapPromise(): Promise<Microsoft.Maps.Map> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const s: ISize = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapService.\r\n     * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        this._config = (<BingMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const overlay: BingCanvasOverlay = new BingCanvasOverlay(drawCallback);\r\n            map.layers.insert(overlay);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const p: Promise<Layer> = new Promise<Layer>(resolve => {\r\n                this.LoadModule('Microsoft.Maps.Clustering', () => {\r\n                    const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n                    const layer: Microsoft.Maps.ClusterLayer = new Microsoft.Maps.ClusterLayer(new Array<Microsoft.Maps.Pushpin>(), o);\r\n                    let bl: BingClusterLayer;\r\n                    map.layers.insert(layer);\r\n                    bl = new BingClusterLayer(layer, this);\r\n                    bl.SetOptions(options);\r\n                    resolve(bl);\r\n                });\r\n            });\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            let loc: Microsoft.Maps.Location;\r\n            if (options.position == null) {\r\n                loc = map.getCenter();\r\n            } else {\r\n                loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);\r\n            }\r\n            const infoBox: Microsoft.Maps.Infobox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));\r\n            infoBox.setMap(map);\r\n            return new BingInfoWindow(infoBox);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const layer: Microsoft.Maps.Layer = new Microsoft.Maps.Layer(options.id.toString());\r\n            map.layers.insert(layer);\r\n            return new BingLayer(layer, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // map startup...\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: Microsoft.Maps.IMapLoadOptions = BingConversions.TranslateLoadOptions(mapOptions);\r\n            if (!o.credentials) {\r\n                o.credentials = this._config.apiKey;\r\n            }\r\n            const map = new Microsoft.Maps.Map(el, o);\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (icon: string, map: Microsoft.Maps.Map): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, map, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            map.entities.push(pushpin);\r\n            return marker;\r\n        };\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof (s) === 'string') { return (payload(s, map)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return (payload(x.icon, map));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, map));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            map.entities.push(poly);\r\n\r\n            const p = new BingPolygon(poly, this, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => p.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            if (options.editable) { p.SetEditable(options.editable); }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline | Array<Polyline>> {\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                map.entities.push(polyline);\r\n\r\n                const pl = new BingPolyline(polyline, map, null);\r\n                if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(p => {\r\n                    polyline = new Microsoft.Maps.Polyline(p, o);\r\n                    map.entities.push(polyline);\r\n\r\n                    const pl = new BingPolyline(polyline, map, null);\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Bing specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            map.layers.remove(layer.NativePrimitve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) {\r\n            return;\r\n        }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance.dispose();\r\n            this._mapInstance = null;\r\n            this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const center = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.latitude,\r\n                longitude: center.longitude\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorth(),\r\n                maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),\r\n                minLatitude: box.getSouth(),\r\n                minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),\r\n                center: { latitude: box.center.latitude, longitude: box.center.longitude },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a shared or private instance of the map drawing tools.\r\n     *\r\n     * @param [useSharedInstance=true] - Set to false to create a private instance.\r\n     * @returns - Promise that when resolved containst an instance of the drawing tools.\r\n     * @memberof BingMapService\r\n     */\r\n    public GetDrawingTools (useSharedInstance: boolean = true): Promise<Microsoft.Maps.DrawingTools> {\r\n        return new Promise<Microsoft.Maps.DrawingTools>((resolve, reject) => {\r\n            this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then((o: Microsoft.Maps.DrawingTools) => {\r\n                resolve(o);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param callback - Callback to call once loading is complete.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModule(moduleName: string, callback: () => void) {\r\n        if (this._modules.has(moduleName)) {\r\n            callback();\r\n        }\r\n        else {\r\n            Microsoft.Maps.loadModule(moduleName, () => {\r\n                this._modules.set(moduleName, null);\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map and delivers and instance of the module payload.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param useSharedInstance- Use a shared instance if true, create a new instance if false.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModuleInstance(moduleName: string, useSharedInstance: boolean = true): Promise<Object> {\r\n        const s: string = moduleName.substr(moduleName.lastIndexOf('.') + 1);\r\n        if (this._modules.has(moduleName)) {\r\n            let o: any = null;\r\n            if (!useSharedInstance)  {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n            }\r\n            else if (this._modules.get(moduleName) != null) {\r\n                o = this._modules.get(moduleName);\r\n            }\r\n            else {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                this._modules.set(moduleName, o);\r\n            }\r\n            return Promise.resolve(o);\r\n        }\r\n        else {\r\n            return new Promise<Object>((resolve, reject) => {\r\n                try {\r\n                Microsoft.Maps.loadModule(moduleName, () => {\r\n                    const o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                    if (useSharedInstance) {\r\n                        this._modules.set(moduleName, o);\r\n                    }\r\n                    else {\r\n                        this._modules.set(moduleName, null);\r\n                    }\r\n                    resolve(o);\r\n                });\r\n                } catch (e) {\r\n                    reject('Could not load module or create instance.');\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n            const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n            if (p != null) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l = locs.map(loc => BingConversions.TranslateLocation(loc));\r\n            const p: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>m.tryLocationToPixel(l,\r\n                Microsoft.Maps.PixelReference.control);\r\n            return p ? p : new Array<IPoint>();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            center: BingConversions.TranslateLocation(latLng)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IMapOptions = BingConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IViewOptions = BingConversions.TranslateViewOptions(options);\r\n            m.setView(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            zoom: zoom\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: Microsoft.Maps.Map) => {\r\n                Microsoft.Maps.Events.addHandler(m, eventNameTranslated, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => Microsoft.Maps.Events.invoke(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Bing Maps V8 archtiecture. It serves\r\n * as the base class for basic layer ({@link BingLayerService}) and cluster layer ({@link BingClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class BingLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const payload = (icon: string, l: Layer): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, null, l.NativePrimitve);\r\n            marker.IsFirst = options.isFirst;\r\n            marker.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            l.AddEntity(marker);\r\n            return marker;\r\n        };\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') { return(payload(s, l)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(x.icon, l));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, l));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string, op: Array<IMarkerOptions>): Array<BingMarker> => {\r\n            const markers: Array<BingMarker> = op.map(mo => {\r\n                let s: string;\r\n                const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '' ) { s = icon; }\r\n                else if (o.icon) {\r\n                    s = o.icon;\r\n                }\r\n                if (o.icon) { delete o.icon; }\r\n                const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(mo.position);\r\n                const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n                const img = Marker.GetImageForMarker(s);\r\n                if (img != null) { (<any>pushpin).image = img; }\r\n\r\n                const marker: BingMarker = new BingMarker(pushpin, null, null);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s, options)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon, options));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve(payload(null, options));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingLayerService extends BingLayerBase implements LayerService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerService.\r\n     * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const layerPromise = this._mapService.CreateLayer({ id: layer.Id });\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => l.SetVisible(layer.Visible));\r\n    }\r\n\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            const polygon: Polygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n\r\n            if (options.metadata) { options.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') {polygon.Title = options.title; }\r\n            if (options.showLabel != null) { polygon.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { polygon.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { polygon.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { polygon.LabelMinZoom = options.labelMinZoom; }\r\n            l.AddEntity(polygon);\r\n            return polygon;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<BingPolygon> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.paths);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(o);\r\n                    const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, op);\r\n                    const polygon: BingPolygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        let line: Polyline;\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                l.AddEntity(line);\r\n\r\n                if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') {line.Title = options.title; }\r\n                if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                return line;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(x => {\r\n                    polyline = new Microsoft.Maps.Polyline(x, o);\r\n                    line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                    l.AddEntity(line);\r\n\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') {line.Title = options.title; }\r\n                    if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                    lines.push(line);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.path);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(o);\r\n                    if (locs && locs.length > 0 && !Array.isArray(locs[0])) {\r\n                        const poly: Microsoft.Maps.Polyline = new Microsoft.Maps.Polyline(locs[0], op);\r\n                        const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        locs.forEach(x => {\r\n                            const poly = new Microsoft.Maps.Polyline(x, op);\r\n                            const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { MapService } from '../map.service';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link ClusterService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingClusterService extends BingLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingClusterService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - ClusterLayerDirective component object.\r\n     * Generally, MapLayer will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            placementMode: layer.ClusterPlacementMode\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.LayerOffset) { options.layerOffset = layer.LayerOffset; }\r\n        if (layer.ZIndex) { options.zIndex = layer.ZIndex; }\r\n        if (layer.IconInfo) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.CustomMarkerCallback) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateCustomClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.SpiderClusterOptions) { options.spiderClusterOptions = layer.SpiderClusterOptions; }\r\n\r\n        const layerPromise: Promise<Layer> = this._mapService.CreateClusterLayer(options);\r\n        (<BingMapService>this._mapService).MapPromise.then(m => {\r\n            Microsoft.Maps.Events.addHandler(m, 'viewchangeend', (e) => {\r\n                if (layer.ClusteringEnabled && m.getZoom() === 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        l.SetOptions({ id: layer.Id, clusteringEnabled: false });\r\n                    });\r\n                }\r\n                if (layer.ClusteringEnabled && m.getZoom() < 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        if (!l.GetOptions().clusteringEnabled) {\r\n                            l.SetOptions({ id: layer.Id, clusteringEnabled: true });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, layerPromise);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StartClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StopClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {@link ClusterLayerDirective} model\r\n     * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all\r\n     * clusters in the layer.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component representing the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            if (layer.IconInfo) {\r\n                const o: Microsoft.Maps.IPushpinOptions = {};\r\n                const payload: (ico: string, info: IMarkerIconInfo) => void = (ico, info) => {\r\n                        o.icon = ico;\r\n                        o.anchor = new Microsoft.Maps.Point(\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0,\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0\r\n                        );\r\n                        cluster.setOptions(o);\r\n                };\r\n                const icon: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(layer.IconInfo);\r\n                if (typeof(icon) === 'string') {\r\n                    payload(icon, layer.IconInfo);\r\n                }\r\n                else {\r\n                    icon.then(x => {\r\n                        payload(x.icon, x.iconInfo);\r\n                    });\r\n                }\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful\r\n     * in situation where the pin should differ to represent information about the pins in the cluster.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component\r\n     * representing the layer. Set the {@link ClusterLayerDirective.CustomMarkerCallback}\r\n     * property to define the callback generating the pin.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateCustomClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            // assemble markers for callback\r\n            const m: Array<Marker> = new Array<Marker>();\r\n            cluster.containedPushpins.forEach(p => {\r\n                const marker: Marker = l.GetMarkerFromBingMarker(p);\r\n                if (marker) { m.push(marker); }\r\n            });\r\n            const iconInfo: IMarkerIconInfo = { markerType: MarkerTypeId.None };\r\n            const o: Microsoft.Maps.IPushpinOptions = {};\r\n            o.icon = layer.CustomMarkerCallback(m, iconInfo);\r\n            if (o.icon !== '') {\r\n                o.anchor = new Microsoft.Maps.Point(\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0,\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0\r\n                );\r\n                if (iconInfo.textOffset) { o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y); }\r\n                cluster.setOptions(o);\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.\r\n     *\r\n     * @param e - Mouse Event.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private ZoomIntoCluster(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.target;\r\n        if (pin && pin.containedPushpins) {\r\n            let bounds: Microsoft.Maps.LocationRect;\r\n            const locs: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            pin.containedPushpins.forEach(p => locs.push(p.getLocation()));\r\n            bounds = Microsoft.Maps.LocationRect.fromLocations(locs);\r\n\r\n            // Zoom into the bounding box of the cluster.\r\n            // Add a padding to compensate for the pixel area of the pushpins.\r\n            (<BingMapService>this._mapService).MapPromise.then((m: Microsoft.Maps.Map) => {\r\n                m.setView({ bounds: bounds, padding: 75 });\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link BingLayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        let polygonPromise: Promise<Polygon>;\r\n        if (polygon.InCustomLayer) {\r\n            polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);\r\n        }\r\n        else {\r\n            polygonPromise = this._mapService.CreatePolygon(o);\r\n        }\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        const x: Microsoft.Maps.IMouseEventArgs = <Microsoft.Maps.IMouseEventArgs>e;\r\n        return { latitude: x.location.latitude, longitude: x.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) =>  {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n    new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * corresponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        let polylinePromise: Promise<Polyline|Array<Polyline>>;\r\n        if (polyline.InCustomLayer) {\r\n            polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);\r\n        } else {\r\n            polylinePromise = this._mapService.CreatePolyline(o);\r\n        }\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polyline) => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.location) { return null; }\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n             x.forEach((line, index) => {\r\n                 if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './bing-infobox.service';\r\nimport { BingMarkerService } from './bing-marker.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerService } from './bing-layer.service';\r\nimport { BingClusterService } from './bing-cluster.service';\r\nimport { BingPolygonService } from './bing-polygon.service';\r\nimport { BingPolylineService } from './bing-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create thre necessary Bing Maps V8 specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapServiceFactory implements MapServiceFactory {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Bing Maps V8 implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new BingMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: BingMapService): ClusterService {\r\n        return new BingClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link BingInfoBoxService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: BingMapService): InfoBoxService {\r\n        return new BingInfoBoxService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: BingMapService): LayerService {\r\n        return new BingLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link BingMarkerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: BingMapService,\r\n        _layerService: BingLayerService, _clusterService: BingClusterService): MarkerService {\r\n        return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new BingPolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new BingPolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @export\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link BingMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns -  A {@link MapServiceFactory} instance.\r\n */\r\nexport function BingMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new BingMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function BingMapLoaderFactory(): MapAPILoader {\r\n    return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Google Maps archtiecture. It serves\r\n * as the base class for basic layer ({@link GoogleLayerService}) and cluster layer ({@link GoogleClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class GoogleLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected abstract _layers: Map<number, Promise<Layer>>;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Google Maps.\r\n     * An instance of {@link GoogleMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or layer id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const mp: Promise<GoogleMapTypes.GoogleMap> = this._mapService.MapPromise;\r\n        const lp: Promise<Layer> = this._layers.get(layer);\r\n\r\n        return Promise.all([mp, lp]).then(([map, l]) => {\r\n            const payload = (x: GoogleMapTypes.MarkerOptions): GoogleMarker => {\r\n                const marker = new google.maps.Marker(x);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                marker.setMap(map);\r\n                const m = new GoogleMarker(marker);\r\n                m.IsFirst = options.isFirst;\r\n                m.IsLast = options.isLast;\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n                l.AddEntity(m);\r\n                return m;\r\n            };\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string): Array<GoogleMarker> => {\r\n            const markers: Array<GoogleMarker> = options.map(mo => {\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '') { o.icon = icon; }\r\n                const pushpin = new google.maps.Marker(o);\r\n                const marker: GoogleMarker = new GoogleMarker(pushpin);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve (payload(null));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","import { IClusterIconInfo } from '../../interfaces/icluster-icon-info';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../marker.service';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\n@Injectable()\r\nexport class GoogleClusterService extends GoogleLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n    protected _layerStyles: Map<number, Array<GoogleMapTypes.ClusterStyle>> = new Map<number, Array<GoogleMapTypes.ClusterStyle>>();\r\n\r\n    ///\r\n    /// Static methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the cluster icon from the styles\r\n     *\r\n     * @param styles\r\n     * @returns - Promise that when resolved contains an Array of IClusterIconInfo objects\r\n     * containing the hydrated cluster icons.\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public static CreateClusterIcons(styles: Array<IClusterIconInfo>): Promise<Array<IClusterIconInfo>> {\r\n        const i: Promise<Array<IClusterIconInfo>> = new Promise<Array<IClusterIconInfo>>((resolve, reject) => {\r\n            const pa = new Array<Promise<{icon: string, iconInfo: IMarkerIconInfo}>>();\r\n            styles.forEach((style, index) => {\r\n                if (style.iconInfo) {\r\n                    const s: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(style.iconInfo);\r\n                    if (typeof(s) === 'string') {\r\n                        style.url = s;\r\n                        if (style.width == null) {\r\n                            style.width = style.iconInfo.size.width;\r\n                            style.height = style.iconInfo.size.height;\r\n                        }\r\n                        if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {\r\n                            const o: IMarkerIconInfo = style.iconInfo;\r\n                            style.anchor = [\r\n                                o.size.width * o.markerOffsetRatio.x,\r\n                                o.size.height * o.markerOffsetRatio.y\r\n                            ];\r\n                        }\r\n                        delete style.iconInfo;\r\n                    }\r\n                    else {\r\n                        s.then(x => {\r\n                            style.url = x.icon;\r\n                            if (style.width == null) {\r\n                                style.width = x.iconInfo.size.width;\r\n                                style.height = x.iconInfo.size.height;\r\n                            }\r\n                            if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {\r\n                                const o: IMarkerIconInfo = x.iconInfo;\r\n                                style.anchor = [\r\n                                    o.size.width * o.markerOffsetRatio.x,\r\n                                    o.size.height * o.markerOffsetRatio.y\r\n                                ];\r\n                            }\r\n                            delete style.iconInfo;\r\n                        });\r\n                        pa.push(s);\r\n                    }\r\n                }\r\n            });\r\n            if (pa.length === 0) { resolve(styles); }\r\n            else {\r\n                Promise.all(pa).then(() => {\r\n                    resolve(styles);\r\n                });\r\n            }\r\n        });\r\n        return i;\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleClusterService.\r\n     * @param _mapService\r\n     * @param _zone\r\n     * @memberof GoogleClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds the cluster layer to the map\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.MinimumClusterSize) { options.minimumClusterSize = layer.MinimumClusterSize; }\r\n        if (layer.Styles) { options.styles = layer.Styles; }\r\n        if (layer.UseDynamicSizeMarkers) {\r\n            options.styles = null;\r\n            // do not to attempt to setup styles here as the dynamic call back will generate them.\r\n        }\r\n        else {\r\n            options.styles = [{\r\n                height: 30,\r\n                width: 35,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n                iconInfo: {\r\n                    markerType: MarkerTypeId.FontMarker,\r\n                    fontName: 'FontAwesome',\r\n                    fontSize: 30,\r\n                    color: 'green',\r\n                    text: '\\uF111'\r\n                }\r\n            }];\r\n        }\r\n        const dynamicClusterCallback = (markers: Array<GoogleMapTypes.Marker>, numStyles: number,\r\n            clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            // dynamically ensure that the necessary style for this cluster icon exists and\r\n            // the clusterer is already hooked up to the styles array via pointer, so we only\r\n            // need to update the style. Since the clusterer re-renders a cluster icon is the\r\n            // the marker count changes, we will only need to retain the current icon as opposed\r\n            // to all cluster icon.\r\n            const styles: Array<GoogleMapTypes.ClusterStyle> = this._layerStyles.get(layer.Id);\r\n            const iconInfo: IMarkerIconInfo = {\r\n                markerType: MarkerTypeId.None\r\n            };\r\n            const icon: string = layer.CustomMarkerCallback(<any>markers, iconInfo);\r\n            styles[0] = {\r\n                url: `\\\"data:image/svg+xml;utf8,${icon}\\\"`,\r\n                height: iconInfo.size.height,\r\n                width: iconInfo.size.width,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n            };\r\n            return {\r\n                text: markers.length.toString(),\r\n                index: 1\r\n            };\r\n        };\r\n        const resetStyles = (clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            if (this._layerStyles.has(layer.Id)) { this._layerStyles.get(layer.Id).splice(0); }\r\n            else {\r\n                const styles: Array<GoogleMapTypes.ClusterStyle> = new Array<GoogleMapTypes.ClusterStyle>();\r\n                styles.push({});\r\n                this._layerStyles.set(layer.Id, styles);\r\n                clusterer.setStyles(styles);\r\n                    // this is important for dynamic styles as the pointer to this array gets passed\r\n                    // around key objects in the clusterer. Therefore, it must be initialized here in order for\r\n                    // updates to the styles to be visible.\r\n                    // also, we need to add at least one style to prevent the default styles from being picked up.\r\n            }\r\n        };\r\n\r\n        const layerPromise = this._mapService.CreateClusterLayer(options);\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => {\r\n            const clusterer: GoogleMapTypes.MarkerClusterer = <GoogleMapTypes.MarkerClusterer>l.NativePrimitve;\r\n            if (options.styles) {\r\n                const s  = GoogleClusterService.CreateClusterIcons(options.styles);\r\n                s.then(x => {\r\n                    clusterer.setStyles(<Array<GoogleMapTypes.ClusterStyle>>x);\r\n                });\r\n            }\r\n            else {\r\n                resetStyles(clusterer);\r\n                this._mapService.MapPromise.then((m: GoogleMapTypes.GoogleMap) => {\r\n                    m.addListener('zoom_changed', () => {\r\n                        resetStyles(clusterer);\r\n                    });\r\n                });\r\n                clusterer.setCalculator((m, n) => {\r\n                    return dynamicClusterCallback(m, n, clusterer);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a marker in the cluster\r\n     *\r\n     * @param layer\r\n     * @param options\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n\r\n        return p.then((l: Layer) => {\r\n            return this._mapService.CreateMarker(options)\r\n                .then((marker: Marker) => {\r\n                    marker.IsFirst = options.isFirst;\r\n                    marker.IsLast = options.isLast;\r\n                    l.AddEntity(marker);\r\n                    return marker;\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Stops the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\n\r\n@Injectable()\r\nexport class GoogleInfoBoxService extends InfoBoxService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<GoogleInfoWindow>>();\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoBoxService.\r\n     * @param _mapService\r\n     * @param _markerService\r\n     * @param _zone\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _markerService: MarkerService,\r\n        private _zone: NgZone) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of an info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n        options.disableAutoPan = info.DisableAutoPan;\r\n        options.visible = info.Visible;\r\n\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = { latitude: info.Latitude, longitude: info.Longitude };\r\n        }\r\n        const infoWindowPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoWindowPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes the info window\r\n     *\r\n     * @param info\r\n     * @returns -  A promise that is resolved when the info box is closed.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then(w => {\r\n            w.Close();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(googleEventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Opens the info window. Window opens on a marker, if supplied, or a specific location if given\r\n     *\r\n     * @param info\r\n     * @param [loc]\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes\r\n            this._boxes.forEach((box: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    box.then((w) => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n            if (info.HostMarker != null) {\r\n                return this._markerService.GetNativeMarker(info.HostMarker).then((marker) => {\r\n                    return this._mapService.MapPromise.then((map) => (<GoogleInfoWindow>w).Open((<GoogleMarker>marker).NativePrimitve));\r\n                });\r\n            }\r\n            return this._mapService.MapPromise.then((map) => {\r\n                if (loc) { w.SetPosition(loc); }\r\n                w.Open();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param info\r\n     * @param options\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            w.SetOptions(options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param info\r\n     * @param latlng\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent, latlng: ILatLong): Promise<void> {\r\n        this._boxes.get(info).then((w) => {\r\n            w.SetPosition(latlng);\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { GoogleMarker } from './google-marker';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of a layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _entities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,\r\n     * so we are returning the Map as the native object because it hosts all the markers.\r\n     *\r\n     * @returns GoogleMapTypes.GoogleMap.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.GoogleMap {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.GoogleMap, private _maps: MapService, private _id: number) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._entities.push(entity);\r\n            entity.NativePrimitve.setVisible(this._visible);\r\n            entity.NativePrimitve.setMap(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            this._entities.push(...entities);\r\n            eachSeries([...entities], (e, next) => {\r\n                e.NativePrimitve.setVisible(this._visible);\r\n                e.NativePrimitve.setMap(this.NativePrimitve);\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer anbd the markers in it.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public Delete(): void {\r\n        eachSeries(this._entities.splice(0), (e, next) => {\r\n            e.NativePrimitve.setMap(null);\r\n            nextTick(() => next());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns ILayerOptions. The layer options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const options: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public RemoveEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            const j: number = this._entities.indexOf(entity);\r\n            if (j > -1) { this._entities.splice(j, 1); }\r\n            entity.NativePrimitve.setMap(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker> | Array<InfoWindow> | Array<Polygon> | Array<Polyline>): void {\r\n        this.Delete();\r\n        this.AddEntities(entities);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions): void {\r\n        this._id = options.id;\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        eachSeries([...this._entities], (e, next) => {\r\n            e.NativePrimitve.setVisible(visible);\r\n            nextTick(() => next());\r\n        });\r\n        this._visible = visible;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a Google Maps specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleLayerService extends GoogleLayerBase implements LayerService  {\r\n\r\n    ///\r\n    /// Field Declarations.\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerService.\r\n     * @param _mapService - Instance of the Google Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const p: Promise<Layer> = new Promise<Layer>((resolve, reject) => {\r\n            this._mapService.MapPromise.then(m => {\r\n                const l: GoogleLayer = new GoogleLayer(m, this._mapService, layer.Id);\r\n                l.SetVisible(layer.Visible);\r\n                resolve(l);\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, p);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Polygon> = this._mapService.CreatePolygon(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => x[1].AddEntity(x[0]));\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        //\r\n        // Note: we attempted using data.Polygons in an attempt to improve performance, but either data.Polygon\r\n        // or data.MultiPolygon actually operate significantly slower than generating the polygons this way.\r\n        // the slowness in google as opposed to bing probably comes from the point reduction algorithm uses.\r\n        // Signigicant performance improvements might be possible in google when using a pixel based reduction algorithm\r\n        // prior to setting the polygon path. This will lower to processing overhead of the google algorithm (with is Douglas-Peucker\r\n        // and rather compute intensive)\r\n        //\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<GooglePolygon> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(o);\r\n                    const poly: GoogleMapTypes.Polygon = new google.maps.Polygon(op);\r\n                    const polygon: GooglePolygon = new GooglePolygon(poly);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((val: any, key: string) => polygon.Metadata.set(key, val)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polyline.\r\n     * @param options - Polyline options defining the polyline.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => {\r\n            const p1: Array<Polyline> =  Array.isArray(x[0]) ? <Array<Polyline>>x[0] : [<Polyline>x[0]];\r\n            for (const p2 of p1) {x[1].AddEntity(p2); }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(o);\r\n                    if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {\r\n                        op.path = GoogleConversions.TranslatePaths(o.path)[0];\r\n                        const poly: GoogleMapTypes.Polyline = new google.maps.Polyline(op);\r\n                        const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(o.path);\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        paths.forEach(x => {\r\n                            op.path = x;\r\n                            const poly = new google.maps.Polyline(op);\r\n                            const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link GoogleMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoaderConfig {\r\n    /**\r\n       * The Google Maps API Key (see:\r\n       * https://developers.google.com/maps/documentation/javascript/get-api-key)\r\n       */\r\n    apiKey?: string;\r\n\r\n    /**\r\n     * The Google Maps client ID (for premium plans).\r\n     * When you have a Google Maps APIs Premium Plan license, you must authenticate\r\n     * your application with either an API key or a client ID.\r\n     * The Google Maps API will fail to load if both a client ID and an API key are included.\r\n     */\r\n    clientId?: string;\r\n\r\n    /**\r\n     * The Google Maps channel name (for premium plans).\r\n     * A channel parameter is an optional parameter that allows you to track usage under your client\r\n     * ID by assigning a distinct channel to each of your applications.\r\n     */\r\n    channel?: string;\r\n\r\n    /**\r\n     * Google Maps API version.\r\n     */\r\n    apiVersion?: string;\r\n\r\n    /**\r\n     * Host and Path used for the `<script>` tag.\r\n     */\r\n    hostAndPath?: string;\r\n\r\n    /**\r\n     * Protocol used for the `<script>` tag.\r\n     */\r\n    protocol?: ScriptProtocol;\r\n\r\n    /**\r\n     * Defines which Google Maps libraries should get loaded.\r\n     */\r\n    libraries?: string[];\r\n\r\n    /**\r\n     * The default bias for the map behavior is US.\r\n     * If you wish to alter your application to serve different map tiles or bias the\r\n     * application, you can overwrite the default behavior (US) by defining a `region`.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Region\r\n     */\r\n    region?: string;\r\n\r\n    /**\r\n     * The Google Maps API uses the browser's preferred language when displaying\r\n     * textual information. If you wish to overwrite this behavior and force the API\r\n     * to use a given language, you can use this setting.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Language\r\n     */\r\n    language?: string;\r\n\r\n    /**\r\n     * The Google Maps API requires a separate library for clustering. Set the property\r\n     * to true in order to load this library.\r\n     * See https://developers.google.com/maps/documentation/javascript/marker-clustering\r\n     */\r\n    enableClustering?: boolean;\r\n\r\n    /**\r\n     * Host and Path used for the cluster library `<script>` tag.\r\n     */\r\n    clusterHostAndPath?: string;\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new GoogleMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public get Config(): GoogleMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapAPILoader.\r\n     * @param _config - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     *                                     Necessary because Bing Map V8 interacts with the document object.\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: GoogleMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `Create`;\r\n        script.src = this.GetMapsScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                if (this._config.enableClustering) {\r\n                    // if clustering is enabled then delay the loading until after the cluster library is loaded\r\n                    const clusterScript = this._documentRef.GetNativeDocument().createElement('script');\r\n                    clusterScript.type = 'text/javascript';\r\n                    clusterScript.src = this.GetClusterScriptSrc();\r\n                    clusterScript.onload = clusterScript.onreadystatechange = () => {\r\n                        resolve();\r\n                    };\r\n                    this._documentRef.GetNativeDocument().head.appendChild(clusterScript);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Google Maps scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Google Maps scripts are loaded.\r\n     * @returns - The url to be used to load the Google Map scripts.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetMapsScriptSrc(callbackName: string) {\r\n        const hostAndPath: string = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\r\n        const queryParams: { [key: string]: string | Array<string> } = {\r\n            v: this._config.apiVersion,\r\n            callback: callbackName,\r\n            key: this._config.apiKey,\r\n            client: this._config.clientId,\r\n            channel: this._config.channel,\r\n            libraries: this._config.libraries,\r\n            region: this._config.region,\r\n            language: this._config.language\r\n        };\r\n        return this.GetScriptSrc(hostAndPath, queryParams);\r\n    }\r\n\r\n    /**\r\n     * Gets the Google Maps Cluster library url for injections into the header.\r\n     *\r\n     * @returns - The url to be used to load the Google Map Cluster library.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetClusterScriptSrc() {\r\n        const hostAndPath: string = this._config.clusterHostAndPath ||\r\n            'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';\r\n        return this.GetScriptSrc(hostAndPath, {});\r\n    }\r\n\r\n    /**\r\n     * Gets a scripts url for injections into the header.\r\n     *\r\n     * @param hostAndPath - Host and path name of the script to load.\r\n     * @param queryParams - Url query parameters.\r\n     * @returns - The url with correct protocol, path, and query parameters.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetScriptSrc(hostAndPath: string, queryParams: { [key: string]: string | Array<string> }): string {\r\n        const protocolType: ScriptProtocol =\r\n            <ScriptProtocol>((this._config && this._config.protocol) || ScriptProtocol.HTTPS);\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const params: string =\r\n            Object.keys(queryParams)\r\n                .filter((k: string) => queryParams[k] != null)\r\n                .filter((k: string) => {\r\n                    // remove empty arrays\r\n                    return !Array.isArray(queryParams[k]) ||\r\n                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\r\n                })\r\n                .map((k: string) => {\r\n                    // join arrays as comma seperated strings\r\n                    const i = queryParams[k];\r\n                    if (Array.isArray(i)) {\r\n                        return { key: k, value: i.join(',') };\r\n                    }\r\n                    return { key: k, value: queryParams[k] };\r\n                })\r\n                .map((entry: { key: string, value: string }) => { return `${entry.key}=${entry.value}`; })\r\n                .join('&');\r\n        return `${protocol}//${hostAndPath}?${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { BehaviorSubject, Observable, Observer } from 'rxjs';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleConversions } from './google-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Google.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarkerService.\r\n     * @param _mapService - {@link MapService} instance.\r\n     * The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link GoogleClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            anchor: marker.Anchor,\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            width: marker.Width,\r\n            height: marker.Height,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarkerDirective} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((ma: Marker) => {\r\n            if (marker.InClusterLayer) {\r\n                this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            if (marker.InCustomLayer) {\r\n                this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            return this._zone.run(() => {\r\n                ma.DeleteMarker();\r\n                this._markers.delete(marker);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        if (this._mapService.MapInstance == null) {\r\n            return null;\r\n        }\r\n\r\n        let crossesDateLine: boolean = false;\r\n        const m = this._mapService.MapInstance;\r\n        const p = m.getProjection();\r\n        const s: number = Math.pow(2, m.getZoom());\r\n        const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n        if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n            b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n        const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n        const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n        const point: GoogleMapTypes.Point = p.fromLatLngToPoint(e.latLng);\r\n        return {\r\n            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n            y: Math.floor((point.y - offsetY) * s)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarkerDirective}\r\n     * or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon. Icon information is present\r\n     * in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const x: IMarkerOptions = {\r\n                    position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n                    iconInfo: marker.IconInfo\r\n                };\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(x);\r\n                m.SetIcon(o.icon);\r\n                marker.DynamicMarkerCreated.emit(x.iconInfo);\r\n            } else {\r\n                m.SetIcon(marker.IconUrl);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n\r\n}\r\n","import { GoogleMarker } from './google-marker';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { timer } from 'rxjs';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarkerClusterer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markerLookup: Map<GoogleMapTypes.Marker, Marker> = new Map<GoogleMapTypes.Marker, Marker>();\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _mapclicks: number = 0;\r\n    private _currentZoom: number = 0;\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns GoogleMapTypes.MarkerClusterer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.MarkerClusterer {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.MarkerClusterer) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof GoogleMarker || isMarker;\r\n        if (isMarker) {\r\n            entity.NativePrimitve.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarker(entity.NativePrimitve);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<GoogleMapTypes.Marker> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                p.NativePrimitve.setMap(null);\r\n                    // remove the marker from the map as the clusterer will control marker visibility.\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarkers(e);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later\r\n                // will render the markers appropriately\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public Delete(): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Google Marker.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetMarkerFromGoogleMarker(pin: GoogleMapTypes.Marker): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: this._layer.getGridSize(),\r\n            clusteringEnabled: this._layer.getGridSize() === 0,\r\n            maxZoom: this._layer.getMaxZoom(),\r\n            minimumClusterSize: this._layer.getMinClusterSize(),\r\n            placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,\r\n            visible: this._visible,\r\n            zoomOnClick: this._layer.isZoomOnClick(),\r\n            styles: this._layer.getStyles()\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                this._layer.removeMarker(entity.NativePrimitve);\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n\r\n        const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                e.NativePrimitve.setMap(null);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                if (this._visible) {\r\n                    this._markers.push(e);\r\n                    p.push(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingMarkers.push(e);\r\n                }\r\n            }\r\n        });\r\n        this._layer.addMarkers(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        if (options.placementMode != null) {\r\n            throw(new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));\r\n        }\r\n        if (options.zoomOnClick != null) {\r\n            throw(new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));\r\n        }\r\n        if (options.callback != null) {}\r\n        if (options.clusteringEnabled != null) {\r\n            this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {\r\n            this._layer.setGridSize(options.gridSize);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.maxZoom != null) { this._layer.setMaxZoom(options.maxZoom); }\r\n        if (options.minimumClusterSize != null) { this._layer.setMinClusterSize(options.minimumClusterSize); }\r\n        if (options.styles != null) { this._layer.setStyles(options.styles); }\r\n        if (options.visible != null) { this.SetVisible(options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const map: GoogleMapTypes.GoogleMap = visible ? this._layer.getMap() : null;\r\n        if (!visible) {\r\n            this._layer.resetViewport(true);\r\n        }\r\n        else {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            if (this._pendingMarkers.length > 0) {\r\n                this._pendingMarkers.forEach(e => {\r\n                    if (e.NativePrimitve && e.Location) {\r\n                        p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                    }\r\n                });\r\n                this._layer.addMarkers(p);\r\n                this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n            }\r\n            else {\r\n                this._layer.redraw();\r\n            }\r\n        }\r\n        this._visible = visible;\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        if (this._visible) {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            this._markers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._pendingMarkers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._layer.addMarkers(p);\r\n            this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        }\r\n\r\n        if (!this._visible) {\r\n            // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the\r\n            // layer is set to visible.\r\n            timer(0).subscribe(() => {\r\n                this._layer.resetViewport(true);\r\n            });\r\n        }\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @returns\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n}\r\n","import { GoogleMarkerClusterer } from '../../models/google/google-marker-clusterer';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/google/google-label';\r\nimport { MixinCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { GoogleCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { Layer } from '../../models/layer';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare const google: any;\r\ndeclare const MarkerClusterer: any;\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Google Maps provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapService implements MapService {\r\n\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapInstance: GoogleMapTypes.GoogleMap;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n    private _config: GoogleMapAPILoaderConfig;\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n\r\n    /**\r\n     * Gets the Google Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapInstance(): GoogleMapTypes.GoogleMap { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapPromise(): Promise<GoogleMapTypes.GoogleMap> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const el: HTMLDivElement = this.MapInstance.getDiv();\r\n            const s: ISize = { width: el.offsetWidth, height: el.offsetHeight };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapService.\r\n     * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<GoogleMapTypes.GoogleMap>(\r\n            (resolve: (map: GoogleMapTypes.GoogleMap) => void) => { this._mapResolver = resolve; }\r\n        );\r\n        this._config = (<GoogleMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const overlay: GoogleCanvasOverlay = new GoogleCanvasOverlay(drawCallback);\r\n            overlay.SetMap(map);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Creates a Google map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            let updateOptions: boolean = false;\r\n            const markerClusterer: GoogleMapTypes.MarkerClusterer = new MarkerClusterer(map, [], options);\r\n            const clusterLayer = new GoogleMarkerClusterer(markerClusterer);\r\n            const o: IClusterOptions = {\r\n                id: options.id\r\n            };\r\n            if (!options.visible) {\r\n                o.visible = false;\r\n                updateOptions = true;\r\n            }\r\n            if (!options.clusteringEnabled) {\r\n                o.clusteringEnabled = false;\r\n                updateOptions = true;\r\n            }\r\n            if (updateOptions) {\r\n                clusterLayer.SetOptions(o);\r\n            }\r\n            return clusterLayer;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<GoogleInfoWindow> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n            const infoWindow: GoogleMapTypes.InfoWindow = new google.maps.InfoWindow(o);\r\n            return new GoogleInfoWindow(infoWindow, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n             return new GoogleLayer(map, this, options.id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // execute map startup\r\n            if (!mapOptions.mapTypeId == null) { mapOptions.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(mapOptions);\r\n            const map: GoogleMapTypes.GoogleMap = new google.maps.Map(el, o);\r\n            if (mapOptions.bounds) {\r\n                map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));\r\n            }\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n            return;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Google map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (x: GoogleMapTypes.MarkerOptions, map: GoogleMapTypes.GoogleMap): GoogleMarker => {\r\n            const marker = new google.maps.Marker(x);\r\n            const m = new GoogleMarker(marker);\r\n            m.IsFirst = options.isFirst;\r\n            m.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n            marker.setMap(map);\r\n            return m;\r\n        };\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o, map);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o, map);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o, map);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n            const polygon: GoogleMapTypes.Polygon = new google.maps.Polygon(o);\r\n            polygon.setMap(map);\r\n\r\n            const p: GooglePolygon = new GooglePolygon(polygon);\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => p.Metadata.set(key, val)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array therefore for complex paths)\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        let polyline: GoogleMapTypes.Polyline;\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                o.path = GoogleConversions.TranslatePaths(options.path)[0];\r\n                polyline = new google.maps.Polyline(o);\r\n                polyline.setMap(map);\r\n\r\n                const pl = new GooglePolyline(polyline);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(options.path);\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                paths.forEach(p => {\r\n                    o.path = p;\r\n                    polyline = new google.maps.Polyline(o);\r\n                    polyline.setMap(map);\r\n\r\n                    const pl = new GooglePolyline(polyline);\r\n                    if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Google specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        // return resolved promise as there is no conept of a custom layer in Google.\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) { return; }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance = null;\r\n            this._map = new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.lat(),\r\n                longitude: center.lng()\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the geo location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorthEast().lat(),\r\n                maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                minLatitude: box.getSouthWest().lat(),\r\n                minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const l: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(loc);\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l);\r\n            return {\r\n                x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                y: Math.floor((point.y - offsetY) * s)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const l = locs.map(ll => {\r\n                const l1: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(ll);\r\n                const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l1);\r\n                return {\r\n                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                    y: Math.floor((point.y - offsetY) * s)\r\n                };\r\n            });\r\n            return l;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n            map.setCenter(center);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            if (options.bounds) {\r\n                m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.setZoom(zoom));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of type E that fires when the event occurs.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n                m.addListener(googleEventName, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => google.maps.event.trigger(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link GoogleLayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        const polygonPromise: Promise<Polygon> = this._mapService.CreatePolygon(o);\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n        new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        const polylinePromise: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(o);\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the line on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked line.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polyline model for the line allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n            x.forEach((line, index) => {\r\n                if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\n\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleInfoBoxService } from './google-infobox.service';\r\nimport { GoogleMarkerService } from './google-marker.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleLayerService } from './google-layer.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { GooglePolygonService } from './google-polygon.service';\r\nimport { GooglePolylineService } from './google-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create three necessary Google Maps specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapServiceFactory implements MapServiceFactory {\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map =\r\n            new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Google Maps implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new GoogleMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: MapService): ClusterService {\r\n        return new GoogleClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param map - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link GoogleInfoBoxService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: MapService, _markerService: MarkerService) {\r\n        return new GoogleInfoBoxService(_mapService, _markerService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: MapService) {\r\n        return new GoogleLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: MapService, _layerService: GoogleLayerService, _clusterService: GoogleClusterService) {\r\n        return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new GooglePolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new GooglePolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link GoogleMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns - A {@link MapServiceFactory} instance.\r\n */\r\nexport function GoogleMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new GoogleMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function GoogleMapLoaderFactory(): MapAPILoader {\r\n    return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { NgModule, ModuleWithProviders, NgZone } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport 'bingmaps';\r\n\r\n///\r\n/// import module interfaces\r\n///\r\nimport { ILatLong } from './src/interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from './src/interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from './src/interfaces/iinfo-window-action';\r\nimport { IMarkerOptions } from './src/interfaces/imarker-options';\r\nimport { IMapOptions } from './src/interfaces/imap-options';\r\nimport { ISize } from './src/interfaces/isize';\r\nimport { IPoint } from './src/interfaces/ipoint';\r\nimport { IBox } from './src/interfaces/ibox';\r\nimport { IMarkerEvent } from './src/interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from './src/interfaces/imarker-icon-info';\r\nimport { ILayerOptions } from './src/interfaces/ilayer-options';\r\nimport { IClusterOptions } from './src/interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from './src/interfaces/ispider-cluster-options';\r\nimport { ILineOptions } from './src/interfaces/iline-options';\r\nimport { IPolygonOptions } from './src/interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from './src/interfaces/ipolyline-options';\r\nimport { IPolygonEvent } from './src/interfaces/ipolygon-event';\r\nimport { IPolylineEvent } from './src/interfaces/ipolyline-event';\r\nimport { IMapEventLookup } from './src/interfaces/imap-event-lookup';\r\nimport { ILabelOptions } from './src/interfaces/ilabel-options';\r\nimport { ICustomMapStyle} from './src/interfaces/icustom-map-style';\r\n\r\n///\r\n/// import module models\r\n///\r\nimport { InfoWindow } from './src/models/info-window';\r\nimport { Marker } from './src/models/marker';\r\nimport { MarkerTypeId } from './src/models/marker-type-id';\r\nimport { MapTypeId } from './src/models/map-type-id';\r\nimport { Layer } from './src/models/layer';\r\nimport { Polygon } from './src/models/polygon';\r\nimport { Polyline } from './src/models/polyline';\r\nimport { SpiderClusterMarker } from './src/models/spider-cluster-marker';\r\nimport { ClusterPlacementMode } from './src/models/cluster-placement-mode';\r\nimport { ClusterClickAction } from './src/models/cluster-click-action';\r\nimport { CanvasOverlay} from './src/models/canvas-overlay';\r\nimport { BingLayer } from './src/models/bing/bing-layer';\r\nimport { BingClusterLayer } from './src/models/bing/bing-cluster-layer';\r\nimport { BingSpiderClusterMarker } from './src/models/bing/bing-spider-cluster-marker';\r\nimport { BingInfoWindow } from './src/models/bing/bing-info-window';\r\nimport { BingMarker } from './src/models/bing/bing-marker';\r\nimport { BingPolygon } from './src/models/bing/bing-polygon';\r\nimport { BingPolyline } from './src/models/bing/bing-polyline';\r\nimport { BingMapEventsLookup } from './src/models/bing/bing-events-lookup';\r\nimport { BingCanvasOverlay } from './src/models/bing/bing-canvas-overlay';\r\nimport { GoogleInfoWindow } from './src/models/google/google-info-window';\r\nimport { GoogleMarker } from './src/models/google/google-marker';\r\nimport { GooglePolygon } from './src/models/google/google-polygon';\r\nimport { GooglePolyline } from './src/models/google/google-polyline';\r\nimport { GoogleMapEventsLookup } from './src/models/google/google-events-lookup';\r\nimport { GoogleCanvasOverlay } from './src/models/google/google-canvas-overlay';\r\n\r\n///\r\n/// import module components\r\n///\r\nimport { MapComponent } from './src/components/map';\r\nimport { MapMarkerDirective } from './src/components/map-marker';\r\nimport { InfoBoxComponent } from './src/components/infobox';\r\nimport { InfoBoxActionDirective } from './src/components/infobox-action';\r\nimport { MapLayerDirective } from './src/components/map-layer';\r\nimport { ClusterLayerDirective } from './src/components/cluster-layer';\r\nimport { MapPolygonDirective } from './src/components/map-polygon';\r\nimport { MapPolylineDirective } from './src/components/map-polyline';\r\nimport { MapMarkerLayerDirective } from './src/components/map-marker-layer';\r\nimport { MapPolygonLayerDirective } from './src/components/map-polygon-layer';\r\nimport { MapPolylineLayerDirective } from './src/components/map-polyline-layer';\r\n\r\n///\r\n/// import module services\r\n///\r\nimport { MapServiceFactory } from './src/services/mapservicefactory';\r\nimport { MapService } from './src/services/map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from './src/services/mapapiloader';\r\nimport { InfoBoxService } from './src/services/infobox.service';\r\nimport { LayerService } from './src/services/layer.service';\r\nimport { MarkerService } from './src/services/marker.service';\r\nimport { ClusterService } from './src/services/cluster.service';\r\nimport { PolygonService } from './src/services/polygon.service';\r\nimport { PolylineService } from './src/services/polyline.service';\r\nimport { BingMapServiceFactory,\r\n    BingMapServiceFactoryFactory, BingMapLoaderFactory } from './src/services/bing/bing-map.service.factory';\r\nimport { BingMapService } from './src/services/bing/bing-map.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './src/services/bing/bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './src/services/bing/bing-infobox.service';\r\nimport { BingMarkerService } from './src/services/bing/bing-marker.service';\r\nimport { BingLayerService } from './src/services/bing/bing-layer.service';\r\nimport { BingClusterService } from './src/services/bing/bing-cluster.service';\r\nimport { BingPolygonService } from './src/services/bing/bing-polygon.service';\r\nimport { BingPolylineService } from './src/services/bing/bing-polyline.service';\r\nimport { GoogleClusterService } from './src/services/google/google-cluster.service';\r\nimport { GoogleInfoBoxService } from './src/services/google/google-infobox.service';\r\nimport { GoogleLayerService } from './src/services/google/google-layer.service';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './src/services/google/google-map-api-loader.service';\r\nimport {\r\n    GoogleMapServiceFactory, GoogleMapServiceFactoryFactory,\r\n    GoogleMapLoaderFactory\r\n} from './src/services/google/google-map.service.factory';\r\nimport { GoogleMapService } from './src/services/google/google-map.service';\r\nimport { GoogleMarkerService } from './src/services/google/google-marker.service';\r\nimport { GooglePolygonService } from './src/services/google/google-polygon.service';\r\nimport { GooglePolylineService } from './src/services/google/google-polyline.service';\r\n\r\n///\r\n/// export publics components, models, interfaces etc for external reuse.\r\n///\r\nexport {\r\n    ILatLong, IInfoWindowOptions, IInfoWindowAction, ISize, IMarkerOptions, IBox, IMapOptions, IPoint, IMarkerEvent, IPolygonEvent,\r\n    IPolylineEvent, IMapEventLookup, IMarkerIconInfo, ILayerOptions, IClusterOptions, ISpiderClusterOptions, ILineOptions,\r\n    IPolygonOptions, IPolylineOptions, ILabelOptions, ICustomMapStyle, MapComponent, InfoBoxComponent, MapMarkerDirective, MapPolygonDirective,\r\n    MapPolylineDirective, InfoBoxActionDirective, MapMarkerLayerDirective, MapPolygonLayerDirective, MapLayerDirective,\r\n    ClusterLayerDirective, MapPolylineLayerDirective, MapTypeId, Marker, MarkerTypeId, InfoWindow, Layer, ClusterPlacementMode,\r\n    ClusterClickAction, SpiderClusterMarker, Polygon, Polyline, CanvasOverlay, MapService, MapServiceFactory, MarkerService,\r\n    InfoBoxService, MapAPILoader, WindowRef, DocumentRef, LayerService, PolygonService, PolylineService, ClusterService\r\n};\r\nexport {\r\n    BingMapServiceFactory, BingMapAPILoaderConfig, BingMapService, BingInfoBoxService,\r\n    BingMarkerService, BingPolygonService, BingPolylineService, BingMapAPILoader,\r\n    BingLayerService, BingClusterService, BingLayer, BingMarker, BingPolyline, BingMapEventsLookup, BingPolygon,\r\n    BingInfoWindow, BingClusterLayer, BingSpiderClusterMarker, BingCanvasOverlay\r\n};\r\nexport {\r\n    GoogleClusterService, GoogleInfoBoxService, GoogleLayerService, GoogleMapAPILoader, GoogleMapAPILoaderConfig,\r\n    GoogleMapServiceFactory, GoogleMapService, GoogleMarkerService, GooglePolygonService, GooglePolylineService,\r\n    GoogleMarker, GoogleInfoWindow, GooglePolygon, GooglePolyline, GoogleMapEventsLookup, GoogleCanvasOverlay\r\n};\r\n\r\n///\r\n/// define module\r\n///\r\n@NgModule({\r\n    declarations: [\r\n        MapLayerDirective,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ],\r\n    imports: [CommonModule],\r\n    exports: [\r\n        CommonModule,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapLayerDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ]\r\n})\r\nexport class MapModule {\r\n\r\n    static forRoot(mapServiceFactory?: MapServiceFactory, loader?: MapAPILoader): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :\r\n                    { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootBing(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootGoogle(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: GoogleMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n}\r\n"]}